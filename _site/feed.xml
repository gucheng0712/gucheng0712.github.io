<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Suzuka Site</title>
    <description>An Otaku who loves making and playing games.</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Tue, 19 Feb 2019 22:17:54 -0800</pubDate>
    <lastBuildDate>Tue, 19 Feb 2019 22:17:54 -0800</lastBuildDate>
    <generator>Jekyll v3.7.4</generator>
    
      <item>
        <title>Data Classification Approaches (ML)</title>
        <description>&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;End –Cheng Gu&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

</description>
        <pubDate>Tue, 29 Jan 2019 17:00:05 -0800</pubDate>
        <link>http://localhost:4000/python/ai/2019/01/29/Data-Classification-Approaches.html</link>
        <guid isPermaLink="true">http://localhost:4000/python/ai/2019/01/29/Data-Classification-Approaches.html</guid>
        
        <category>Python</category>
        
        <category>Ai</category>
        
        
        <category>Python</category>
        
        <category>Ai</category>
        
      </item>
    
      <item>
        <title>Linear Regression (ML)</title>
        <description>&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;End –Cheng Gu&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

</description>
        <pubDate>Mon, 21 Jan 2019 17:00:05 -0800</pubDate>
        <link>http://localhost:4000/python/ai/2019/01/21/Linear-Regression.html</link>
        <guid isPermaLink="true">http://localhost:4000/python/ai/2019/01/21/Linear-Regression.html</guid>
        
        <category>Python</category>
        
        <category>Ai</category>
        
        
        <category>Python</category>
        
        <category>Ai</category>
        
      </item>
    
      <item>
        <title>Data Preprocessing Techniques (ML)</title>
        <description>&lt;p&gt;In order to start machine learning training process, the algorithms needs to make the data be formatted in certain way. This is called &lt;strong&gt;&lt;em&gt;Data Preprocessing&lt;/em&gt;&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;There are many ways of doing data preprocessing, the most common ways are &lt;strong&gt;&lt;em&gt;Binarization, Mean Removal, Scaling&lt;/em&gt;&lt;/strong&gt;, and &lt;strong&gt;&lt;em&gt;Normalization&lt;/em&gt;&lt;/strong&gt;.&lt;/p&gt;

&lt;hr /&gt;
&lt;h4 id=&quot;1-binarization&quot;&gt;1. Binarization&lt;/h4&gt;

&lt;p&gt;Binarization is the process of convert the numerical values into boolean values based on a threshold value.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;For example:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    import numpy as np  # numpy library
    from sklearn import preprocessing  # sklearn library
   	#inputs
    input_data = np.array([
        [5.1, -2.9, 3.3],
        [-1.2, 7.8, -6.1],
        [3.9, 0.4, 2.1],
        [7.3, -9.9, -4.5]])
        
    # Binarize Data based on teh threshold 2.1, every element above the threshold will be 1, else 0
    data_binarized = preprocessing.Binarizer(threshold = 2.1).transform(input_data)
    print(&quot;\nBinarized Data:\n&quot;,data_binarized)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;Output:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;   Binarized data:
    [[ 1.  0.  1.]
    [ 0.  1.  0.]
    [ 1.  0.  0.]
    [ 1.  0.  0.]]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;
&lt;h4 id=&quot;2-mean-removal&quot;&gt;2. Mean Removal&lt;/h4&gt;

&lt;p&gt;Removing the mean is commonly used in machine learning. It usually useful to remove the mean from out feature vector, so that each feature is centered on zero. We do this in order to remove bias from the features in our feature vector.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;For example:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    import numpy as np  # numpy library
    from sklearn import preprocessing  # sklearn library
   	#inputs
    input_data = np.array([
        [5.1, -2.9, 3.3],
        [-1.2, 7.8, -6.1],
        [3.9, 0.4, 2.1],
        [7.3, -9.9, -4.5]])
        
    # Standard Deviation: The size of the fluctuations in the data set
    # Print mean and standard deviation
    print(&quot;\nDataBeforeMeanRemoval: \n&quot;, input_data)
    print(&quot;\nBEFORE:&quot;)
    print(&quot;Mean = &quot;, input_data.mean(axis=0))  # axis represents the mean's dimension 0 -&amp;gt; vertical   1 -&amp;gt; horizontal
    print(&quot;Std Deviation = &quot;, input_data.std(axis=0))
    print(&quot;Mean = &quot;, input_data.mean(axis=1))
    print(&quot;Std Deviation = &quot;, input_data.std(axis=1))

    # Remove Mean by scale function
    data_scaled = preprocessing.scale(input_data)
    print(&quot;\nDataAfterMeanRemoval: \n&quot;, data_scaled)
    print('\nAFTER:')
    print('Mean = ', data_scaled.mean(axis=0))
    print(&quot;Std Deviation = &quot;, data_scaled.std(axis=0))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;Output:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    DataBeforeMeanRemoval: 
     [[ 5.1 -2.9  3.3]
     [-1.2  7.8 -6.7]
     [ 3.9  0.4  2.1]
     [ 7.3 -9.9 -4.5]]

    BEFORE:
    Mean =  [ 3.775 -1.15  -1.45 ]
    Std Deviation =  [3.12039661 6.36651396 4.24352448]
    Mean =  [ 1.83333333 -0.03333333  2.13333333 -2.36666667]
    Std Deviation =  [3.42669261 5.97680703 1.42906341 7.18207646]

    DataAfterMeanRemoval: 
     [[ 0.42462551 -0.2748757   1.11935256]
     [-1.59434861  1.40579288 -1.23717915]
     [ 0.04005901  0.24346134  0.83656876]
     [ 1.12966409 -1.37437851 -0.71874217]]

    AFTER:
    Mean =  [1.11022302e-16 0.00000000e+00 5.55111512e-17]
    Std Deviation =  [1. 1. 1.]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;
&lt;h4 id=&quot;3-rescale-data&quot;&gt;3. Rescale Data&lt;/h4&gt;

&lt;p&gt;The process of normalization is to modify the values in the vector so that we can measure them on a common scale.&lt;/p&gt;

&lt;p&gt;There are 2 common normalization techniques:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;&lt;em&gt;L1 Normalization&lt;/em&gt;&lt;/strong&gt;, which refers to Least Absolute Deviations, works by making sure that the sum of absolute values is 1 in each row.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;em&gt;L2 Normalization&lt;/em&gt;&lt;/strong&gt;, which refers to least squares, works by making sure that the sum of squares is 1.&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;For example:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    import numpy as np  # numpy library
    from sklearn import preprocessing  # sklearn library
   	#inputs
    input_data = np.array([
        [5.1, -2.9, 3.3],
        [-1.2, 7.8, -6.1],
        [3.9, 0.4, 2.1],
        [7.3, -9.9, -4.5]])
        
    # Min max scaling
    data_scaler_minmax = preprocessing.MinMaxScaler(feature_range=(0, 1))  # create a (0,1) data scalar
    data_scaled_minmax = data_scaler_minmax.fit_transform(input_data)  # scalar the data by using scalar
    print(&quot;\nMin max scaled data:\n&quot;, data_scaled_minmax)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;Output:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    Min max scaled data:
     [[0.74117647 0.39548023 1.       ]
     [0.         1.         0.        ]
     [0.6        0.5819209  0.88      ]
     [1.         0.         0.22      ]]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;4-normalization&quot;&gt;4. Normalization&lt;/h4&gt;

&lt;p&gt;In vector, the value of each feature can vary between many random values, so rerange(scaling) the values are important.
It is often rescaled into the range between 0 and 1. This is useful for optimization algorithms, such as like gradient descent, weight inputs.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;For example:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    import numpy as np  # numpy library
    from sklearn import preprocessing  # sklearn library
   	#inputs
    input_data = np.array([
        [5.1, -2.9, 3.3],
        [-1.2, 7.8, -6.1],
        [3.9, 0.4, 2.1],
        [7.3, -9.9, -4.5]])
        
    # Normalize Data

    # L1 Normalization ==&amp;gt; the sum of absolute value is 1 in each row (Least Absolute Deviation)
    # L2 Normalization ==&amp;gt; the sum of squares is 1
    data_normalized_l1 = preprocessing.normalize(input_data, norm='l1')
    data_normalized_l2 = preprocessing.normalize(input_data, norm='l2')  # default more stable
    print(&quot;\nL1 Normalized Data:\n&quot;, data_normalized_l1)
    print(&quot;\nL2 Normalized Data:\n&quot;, data_normalized_l2)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;Output:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    L1 Normalized Data:
     [[ 0.45132743 -0.25663717  0.2920354 ]
     [-0.07643312  0.49681529 -0.42675159]
     [ 0.609375    0.0625      0.328125  ]
     [ 0.33640553 -0.4562212  -0.20737327]]

    L2 Normalized Data:
     [[ 0.75765788 -0.43082507  0.49024922]
     [-0.11591633  0.75345616 -0.64719952]
     [ 0.87690281  0.08993875  0.47217844]
     [ 0.55734935 -0.75585734 -0.34357152]]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;End –Cheng Gu&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

</description>
        <pubDate>Mon, 21 Jan 2019 17:00:05 -0800</pubDate>
        <link>http://localhost:4000/python/ai/2019/01/21/DataPreprocessing.html</link>
        <guid isPermaLink="true">http://localhost:4000/python/ai/2019/01/21/DataPreprocessing.html</guid>
        
        <category>Python</category>
        
        <category>Ai</category>
        
        
        <category>Python</category>
        
        <category>Ai</category>
        
      </item>
    
      <item>
        <title>IComparable and IComparer</title>
        <description>&lt;p&gt;In Collection class, when we are going to use simple Sort() function in a List, the base types all provide default comparison algorithms, such as string that provides the alphabetic comparisions and int that provides integer comparisions.&lt;/p&gt;

&lt;p&gt;However, when we create our own class. If we want to sort the certain variable in the object list, the class need to implement the IComparable Interface.&lt;/p&gt;

&lt;hr /&gt;
&lt;h4 id=&quot;1-sorting-integer-and-string-lists&quot;&gt;1. Sorting Integer and String Lists&lt;/h4&gt;

&lt;p&gt;If the elements inside the list are strings, it will sort by the first letter of the string:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Code:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;   	List&amp;lt;string&amp;gt; strList = new List&amp;lt;string&amp;gt;() { &quot;Tom&quot;, &quot;Jerry&quot;, &quot;Joab&quot;, &quot;Edi&quot;, &quot;Kane&quot;, &quot;Hans&quot; };
       strList.Sort();
       strList.ForEach(Console.WriteLine);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;Output:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    Edi
    Hans
    Jerry
    Joab
    Kane
    Tom
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;If the elements inside the list are integers, it will sort by the integer from small to big:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Code:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    List&amp;lt;int&amp;gt; nums = new List&amp;lt;int&amp;gt;() { 2, 33, 22, 1, 5, 8 };
    nums.Sort();
    nums.ForEach(Console.WriteLine);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;Output:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    1
    2
    5
    8
    22
    33
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;However, if you create a &lt;code class=&quot;highlighter-rouge&quot;&gt;Human&lt;/code&gt; class, and declare a variable called Name, you want to sort the Human by name, it will give you an error after you using &lt;code class=&quot;highlighter-rouge&quot;&gt;Sort()&lt;/code&gt; function, if you didn’t implement the &lt;code class=&quot;highlighter-rouge&quot;&gt;IComparable&lt;/code&gt; Interface in the &lt;code class=&quot;highlighter-rouge&quot;&gt;Human&lt;/code&gt; class.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Code:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    class Human
    {
        public string Name { get; set; }
        public int Age { get; set; }

        public Human(string name, int age)
        {
            Name = name;
            Age = age;
        }
    }
    --------------------
    public static void Main(string[] args)
    {
        List&amp;lt;Human&amp;gt; human = new List&amp;lt;Human&amp;gt;()
        {
            new Human(&quot;Tom&quot;,22),
            new Human(&quot;Jerry&quot;,12),
            new Human(&quot;Joab&quot;,18),
            new Human(&quot;Kyroll&quot;,11),
            new Human(&quot;Cheng Gu&quot;,19)
        };

        human.Sort();
        human.ForEach(Console.WriteLine);
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;Output:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;System.Collections.Generic.ArraySortHelper&amp;lt;Human&amp;gt;.Sort(Human[] keys, int index, int length, System.Collections.Generic.ObjectComparer&amp;lt;Human&amp;gt; comparer) in /Users/builder/jenkins/workspace/build-package-osx-mono/2018-02/external/bockbuild/builds/mono-x64/external/corert/src/System.Private.CoreLib/src/System/Collections/Generic/ArraySortHelper.cs:66
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;
&lt;h4 id=&quot;2-icomparable&quot;&gt;2. IComparable&lt;/h4&gt;

&lt;p&gt;So Only if you implement the &lt;code class=&quot;highlighter-rouge&quot;&gt;IComparable&lt;/code&gt; Interface&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;So, lets sort Human by name
Code:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    class Human : IComparable&amp;lt;Human&amp;gt;
    {
        public string Name { get; set; }
        public int Age { get; set; }

        public Human(string name, int age)
        {
            Name = name;
            Age = age;
        }

        public int CompareTo(Human other)
        {
            if (Age &amp;gt; other.Age) { return 1; }
            else if (Age &amp;lt; other.Age) { return -1; }
            else { return 0; }

            /* 
             * Below is the default CompareTo() which does the same thing as above, 
             * used here to better illustrate how the comparator works.
             */
            // return Age.CompareTo(other.Age);
        }

        public override string ToString()
        {
            return Name + &quot; &quot; + Age;
        }
    }
    ----------------
    public static void Main(string[] args)
    {
        List&amp;lt;Human&amp;gt; human = new List&amp;lt;Human&amp;gt;()
        {
            new Human(&quot;Tom&quot;,22),
            new Human(&quot;Jerry&quot;,12),
            new Human(&quot;Joab&quot;,18),
            new Human(&quot;Kyroll&quot;,11),
            new Human(&quot;Cheng Gu&quot;,19)
        };
        human.Sort();
        human.ForEach(Console.WriteLine);
    }
    
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;Output:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    Kyroll 11
    Jerry 12
    Joab 18
    Cheng Gu 19
    Tom 22
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;
&lt;h4 id=&quot;3-icomparator&quot;&gt;3. IComparator&lt;/h4&gt;

&lt;p&gt;Now, The &lt;code class=&quot;highlighter-rouge&quot;&gt;IComparable&lt;/code&gt; Interface solved the sorting error. There is another question pop up. What if you don’t want to Sort by age, you want to sort by human’s name, so you can use IComparer to implement a custom comparator.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Code:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    class Human : IComparable&amp;lt;Human&amp;gt;
    {
        public string Name { get; set; }
        public int Age { get; set; }

        public Human(string name, int age)
        {
            Name = name;
            Age = age;
        }

        public int CompareTo(Human other)
        {
            if (Age &amp;gt; other.Age) { return 1; }
            else if (Age &amp;lt; other.Age) { return -1; }
            else { return 0; }

            /* 
             * Below is the default CompareTo() which does the same thing as above, 
             * used here to better illustrate how the comparator works.
             */
            // return Age.CompareTo(other.Age);
        }

        public override string ToString()
        {
            return Name + &quot; &quot; + Age;
        }

    }
    ----------
    class HumanNameComparer : IComparer&amp;lt;Human&amp;gt;
    {
        public int Compare(Human x, Human y)
        {
            return x.Name.CompareTo(y.Name);
        }
    }
    ----------
    class MainClass
    {
        public static void Main(string[] args)
        {
            List&amp;lt;Human&amp;gt; human = new List&amp;lt;Human&amp;gt;()
            {
                new Human(&quot;Tom&quot;,22),
                new Human(&quot;Jerry&quot;,12),
                new Human(&quot;Joab&quot;,18),
                new Human(&quot;Kyroll&quot;,11),
                new Human(&quot;Cheng Gu&quot;,19)
            };
            human.Sort(new HumanNameComparer());
            human.ForEach(Console.WriteLine);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;Output:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    Cheng Gu 19
    Jerry 12
    Joab 18
    Kyroll 11
    Tom 22
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;End –Cheng Gu&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

</description>
        <pubDate>Sun, 30 Sep 2018 18:00:05 -0700</pubDate>
        <link>http://localhost:4000/csharp/2018/09/30/IComparable-and-IComparer-copy.html</link>
        <guid isPermaLink="true">http://localhost:4000/csharp/2018/09/30/IComparable-and-IComparer-copy.html</guid>
        
        <category>Csharp</category>
        
        
        <category>Csharp</category>
        
      </item>
    
      <item>
        <title>CubeMap</title>
        <description>&lt;p&gt;In CG, CubeMap is the way to achieve Environment Mapping. it can simulate the environment around the object, make the object be able to reflect the environment around itself.&lt;/p&gt;

&lt;p&gt;Cubemap includes 6 images. these images correspond to the six sides of a cube.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;So How to sample this Cubemap Texture?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Different from sampling the 2D Texture, it needs a 3D Texture coordinate to sample a Cubemap. This 3D texture coordiate represents a 3D direction vector of a object in the world space. This Vector starts from the center of the cube, And a direction vector only represent the dir, so it can be think of infinity length, when it extend its length, eventually it will intersect with one of the cube’s six textures, the result of sampling is calculated with the intersection point. just like below image.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;     
&lt;img src=&quot;/static/assets/img/blog/cubemapSampler.png&quot; width=&quot;50%&quot; /&gt;
&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Pros of using Cubemap&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;Easy and Fast.&lt;/li&gt;
  &lt;li&gt;Effects of Cubemap are not bad.&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;Cons of using Cubemap&lt;/p&gt;
  &lt;ol&gt;
    &lt;li&gt;When introducing a new object in the scene, the light source, or an object moves, we need to regenerate the cube texture.&lt;/li&gt;
    &lt;li&gt;The Cubemap texture can not simulate the result of the multiple reflections, such as two metal ball reflection of each other.&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Therefore, we should use Cubemap texture for convex objects and do not use it for concave objects (because the concave objects reflect itself)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;
&lt;h4 id=&quot;1-reflection&quot;&gt;1. Reflection&lt;/h4&gt;

&lt;p&gt;To simulate the reflection effect, we simply need to calculate the direction of the reflection by the direction of the incident ray(which is the negative view direction) and the normal direction of the surface. Finally, the reflection direction is used to sample the Cubemap texture.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;     
&lt;img src=&quot;/static/assets/img/blog/reflection.png&quot; width=&quot;50%&quot; /&gt;
&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Properties:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;   	Properties
    {
        _Color(&quot;Color&quot;,Color) = (1,1,1,1)
        _ReflectColor(&quot;Reflect Color&quot;, Color) = (1,1,1,1)
        _ReflectAmount(&quot;Reflect Amount&quot;, Range(0,1)) = 1
        _Cubemap(&quot;Reflection Cubemap&quot;, Cube) = &quot;_Skybox&quot;{}
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;VertexShader:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    v2f vert(a2v v)
    {
        v2f f;
        f.pos = UnityObjectToClipPos(v.vertex);
        f.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
        f.worldNormal = mul(v.normal,unity_WorldToObject);
        f.worldViewDir = UnityWorldSpaceViewDir(f.worldPos);
        f.worldRefl = reflect(-f.worldViewDir,f.worldNormal);
        TRANSFER_SHADOW(f);
        return f;
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;FragmentShader:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    fixed4 frag(v2f f):SV_Target
    {
        fixed3 worldNormal = normalize(f.worldNormal);
        fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(f.worldPos));
        
        fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.rgb;
        
        fixed3 diffuse = _LightColor0.rgb * _Color.rgb *max(0, dot(worldNormal,worldLightDir));
        fixed3 reflection = texCUBE(_Cubemap,f.worldRefl).rgb * _ReflectColor.rgb;
        
        UNITY_LIGHT_ATTENUATION(atten, f, f.worldPos);
        
        fixed3 color = ambient+lerp(diffuse,reflection,_ReflectAmount)*atten;
        
        return fixed4(color,1.0);
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;
&lt;h4 id=&quot;2-refraction&quot;&gt;2. Refraction&lt;/h4&gt;

&lt;p&gt;Refraction: When light rays from one medium, such as air, are deflected into another, such as glass, the direction of propagation generally changes, this phenomenon is called refraction.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Snell’s Law:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/static/assets/img/blog/SnellLaw.png&quot; width=&quot;15%&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;n1 and n2 are the medium’s percentage of refraction.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/static/assets/img/blog/refractionDefinition.png&quot; width=&quot;30%&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Result:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p class=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/PostImages/refraction.png&quot; alt=&quot;dot&quot; height=&quot;50%&quot; width=&quot;50%&quot; /&gt;&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;  
&lt;img src=&quot;/static/assets/img/blog/refraction.png&quot; width=&quot;50%&quot; /&gt;
&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Properties:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;        _Color(&quot;Color&quot;,Color) = (1,1,1,1)
        _RefractColor(&quot;Reflect Color&quot;, Color) = (1,1,1,1)
        _RefractAmount(&quot;Reflect Amount&quot;, Range(0,1)) = 1
        
        // The Percentage of Differnet Medium
        // eg: Refraction Percentage of Air/ Refraction Percentage of Glass
        _RefractRatio(&quot;Refract Ratio&quot;,Range(0.1,1)) = 0.5  
        _Cubemap(&quot;Reflection Cubemap&quot;, Cube) = &quot;_Skybox&quot;{}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;VertexShader:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;        v2f vert(a2v v)
        {
            v2f f;
            f.pos = UnityObjectToClipPos(v.vertex);
            f.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
            f.worldNormal = mul(v.normal,unity_WorldToObject);
            f.worldViewDir = UnityWorldSpaceViewDir(f.worldPos);
            f.worldRefr = refract(-normalize(f.worldViewDir),normalize(f.worldNormal),_RefractRatio);
            TRANSFER_SHADOW(f);
            return f;
        }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;FragmentShader:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;        fixed4 frag(v2f f):SV_Target
        {
            fixed3 worldNormal = normalize(f.worldNormal);
            fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(f.worldPos));
            
            fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.rgb;
            
            fixed3 diffuse = _LightColor0.rgb * _Color.rgb *max(0, dot(worldNormal,worldLightDir));
            fixed3 refraction = texCUBE(_Cubemap,f.worldRefr).rgb * _RefractColor.rgb;
            
            UNITY_LIGHT_ATTENUATION(atten, f, f.worldPos);
            
            fixed3 color = ambient+lerp(diffuse,refraction,_RefractAmount)*atten;
            
            return fixed4(color,1.0);
        }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;
&lt;h4 id=&quot;3-fresnel-reflection&quot;&gt;3. Fresnel Reflection&lt;/h4&gt;

&lt;p&gt;Fresnel Reflection Represents a Optical Phenomenon. When light hits the surface of an object, some parts occur reflection, some parts goes into the inside of the object, or occur refraction or scattering.&lt;/p&gt;

&lt;p&gt;For example, When you stand by the lake and look down at the water at your feet, you will find that the water is almost transparent. You can see the small fish and stones directly. But when you look up at the water in the distance, you will find that you can hardly see the underwater scene, but only the environment that reflects the water.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;A Famous Equation is called Schlick’s Approximation&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/static/assets/img/blog/schlick.png&quot; width=&quot;25%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;In this equation, F0 is a reflection coefficient, which is used to control the magnitude of the reflection, v is the view dir, n is normal dir.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;     
&lt;img src=&quot;/static/assets/img/blog/schlickPP.png&quot; width=&quot;50%&quot; /&gt;
&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Properties:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;        _Color(&quot;Color&quot;,Color) = (1,1,1,1)
        _FresnelScale(&quot;Fresnel Scale&quot;,Range(0,1))=0.5
        _Cubemap(&quot;Reflection Cubemap&quot;, Cube) = &quot;_Skybox&quot;{}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;VertexShader:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;        v2f vert(a2v v)
        {
            v2f f;
            f.pos = UnityObjectToClipPos(v.vertex);
            f.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
            f.worldNormal = mul(v.normal,unity_WorldToObject);
            f.worldViewDir = UnityWorldSpaceViewDir(f.worldPos);
            f.worldRefl = reflect(-f.worldViewDir,f.worldNormal);
            TRANSFER_SHADOW(f);
            return f;
        }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;FragmentShader:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;        fixed4 frag(v2f f):SV_Target
        {
            fixed3 worldNormal = normalize(f.worldNormal);
            fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(f.worldPos));
            fixed3 worldViewDir = normalize(f.worldViewDir);
            
            fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.rgb;
            
            fixed3 diffuse = _LightColor0.rgb * _Color.rgb *max(0, dot(worldNormal,worldLightDir));
            fixed3 reflection = texCUBE(_Cubemap,f.worldRefl).rgb;
            
            fixed fesnel = _FresnelScale+(1-_FresnelScale)*pow(1-dot(worldViewDir,worldNormal),5);
            
            UNITY_LIGHT_ATTENUATION(atten, f, f.worldPos);
            
            fixed3 color = ambient+lerp(diffuse, reflection, fesnel) * atten;
            
            return fixed4(color,1.0);
        }   
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;End –Cheng Gu&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

</description>
        <pubDate>Sat, 22 Sep 2018 00:00:00 -0700</pubDate>
        <link>http://localhost:4000/cg/unity/2018/09/22/CubeMap.html</link>
        <guid isPermaLink="true">http://localhost:4000/cg/unity/2018/09/22/CubeMap.html</guid>
        
        <category>Unity</category>
        
        <category>Shader</category>
        
        <category>Math</category>
        
        <category>CG</category>
        
        
        <category>Cg</category>
        
        <category>Unity</category>
        
      </item>
    
      <item>
        <title>Observer Pattern in C#</title>
        <description>&lt;p&gt;Use observer pattern to implement A cat and few mice. When cat comes all the mices are running away.&lt;/p&gt;

&lt;hr /&gt;
&lt;h4 id=&quot;1-normal-ways-violates-the-open-closed-principle&quot;&gt;1. Normal ways (Violates the Open Closed Principle)&lt;/h4&gt;

&lt;p align=&quot;center&quot;&gt;     
&lt;img src=&quot;/static/assets/img/blog/Normal.png&quot; width=&quot;50%&quot; /&gt;
&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Code:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    public class Normal : MonoBehaviour
    {
        Cat ws = new Cat();
        MouseA a = new MouseA();
        MouseB b = new MouseB();
        MouseC c = new MouseC();

        private void Update()
        {
            if (Input.GetKeyDown(KeyCode.Space))
            {
                ws.CatComing(a, b, c);
            }
        }
    }
    
==================================Class Division================================
    class Cat
    {
        public void CatComing(MouseA a, MouseB b, MouseC c)
        {
            Debug.Log(&quot;Cat is coming&quot;);
            a.RunAway();
            b.RunAway();
            c.RunAway();
        }
    }
    
==================================Class Division================================
    class MouseA
    {
        public void RunAway()
        {
            Debug.Log(&quot;Mouse A Run away&quot;);
        }

    }
    
==================================Class Division================================
    class MouseB
    {
        public void RunAway()
        {
            Debug.Log(&quot;Mouse B Run away&quot;);
        }

    }
    
==================================Class Division================================
    class MouseC
    {
        public void RunAway()
        {
            Debug.Log(&quot;Mouse C Run away&quot;);
        }

    }

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;
&lt;h4 id=&quot;2-observerpattern-complex-but-often-used-in-big-framework&quot;&gt;2. ObserverPattern (Complex but often used in big framework)&lt;/h4&gt;

&lt;p align=&quot;center&quot;&gt;     
&lt;img src=&quot;/static/assets/img/blog/OB.png&quot; width=&quot;50%&quot; /&gt;
&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Code:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    public class ObserverPattern : MonoBehaviour
    {
        Cat cat = new Cat();

        void Start()
        {
            MouseA mouseA = new MouseA(cat);
            MouseB mouseB = new MouseB(cat);
            MouseC mouseC = new MouseC(cat);
            cat.AddObserver(mouseA);
            cat.AddObserver(mouseB);
            cat.AddObserver(mouseC);
        }

        private void Update()
        {
            if (Input.GetKeyDown(KeyCode.Space))
            {
                cat.CatComing();
            }
        }

    }
    
==================================Class Division================================
    abstract class Subject
    {
        List&amp;lt;Observer&amp;gt; m_observers = new List&amp;lt;Observer&amp;gt;();

        public void AddObserver(Observer ob)
        {
            m_observers.Add(ob);
        }

        public void RemoveObserver(Observer ob)
        {
            m_observers.Remove(ob);
        }

        public void NotifyObserver()
        {
            foreach (var o in m_observers)
            {
                o.Update();
            }
        }
    }

==================================Class Division================================
    class Cat : Subject
    {
        public void CatComing()
        {
            Debug.Log(&quot;Cat is Comming&quot;);
            NotifyObserver();
        }
    }

==================================Class Division================================
    abstract class Observer
    {
        public abstract void Update();
    }

==================================Class Division================================
    class MouseA : Observer
    {
        public Cat cat;

        public MouseA(Cat _cat)
        {
            cat = _cat;
        }

        public override void Update()
        {
            RunAway();
        }

        private void RunAway()
        {
            Debug.Log(&quot;MouseA is run away&quot;);
        }
    }

==================================Class Division================================
    class MouseB : Observer
    {
        public Cat cat;

        public MouseB(Cat _cat)
        {
            cat = _cat;
        }

        public override void Update()
        {
            RunAway();
        }

        private void RunAway()
        {
            Debug.Log(&quot;MouseB is run away&quot;);
        }
    }
    
==================================Class Division================================
    class MouseC : Observer
    {
        public Cat cat;

        public MouseC(Cat _cat)
        {
            cat = _cat;
        }

        public override void Update()
        {
            RunAway();
        }

        private void RunAway()
        {
            Debug.Log(&quot;MouseC is run away&quot;);
        }
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/gucheng0712/ObserverPattern&quot;&gt;ObserverPattern with multiple Subjects&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;
&lt;h4 id=&quot;3-observer-pattern-by-using-c-event-simple-and-neat&quot;&gt;3. Observer Pattern By using C# Event (Simple and Neat)&lt;/h4&gt;

&lt;p align=&quot;center&quot;&gt;     
&lt;img src=&quot;/static/assets/img/blog/OB_Event.png&quot; width=&quot;50%&quot; /&gt;
&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Code:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    public class ObserverPattern_Delegate : MonoBehaviour
    {
        Cat cat = new Cat();
        MouseA mouseA = new MouseA();
        MouseB mouseB = new MouseB();
        MouseC mouseC = new MouseC();


        private void Start()
        {
            cat.CatComeEvent += mouseA.RunAway;
            cat.CatComeEvent += mouseB.RunAway;
            cat.CatComeEvent += mouseC.RunAway;
        }

        private void Update()
        {
            if (Input.GetKeyDown(KeyCode.Space))
            {
                cat.CatComing();
            }
        }
    }

==================================Class Division================================
    class Cat
    {
        public delegate void CatComeEventHandler();
        public event CatComeEventHandler CatComeEvent;

        public void CatComing()
        {
            Debug.Log(&quot;Cat is Coming&quot;);
            if (CatComeEvent != null)
            {
                CatComeEvent();
            }
        }
    }

==================================Class Division================================
    class MouseA
    {
        public void RunAway()
        {
            Debug.Log(&quot;MouseA,Run, Cat is coming&quot;);
        }
    }
    
==================================Class Division================================
    class MouseB
    {
        public void RunAway()
        {
            Debug.Log(&quot;MouseB,Run, Cat is coming&quot;);
        }
    }

==================================Class Division================================
    class MouseC
    {
        public void RunAway()
        {
            Debug.Log(&quot;MouseC,Run, Cat is coming&quot;);
        }
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;End –Cheng Gu&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

</description>
        <pubDate>Sun, 16 Sep 2018 00:00:00 -0700</pubDate>
        <link>http://localhost:4000/csharp/2018/09/16/Observer-Pattern-in-C.html</link>
        <guid isPermaLink="true">http://localhost:4000/csharp/2018/09/16/Observer-Pattern-in-C.html</guid>
        
        <category>Csharp</category>
        
        
        <category>Csharp</category>
        
      </item>
    
      <item>
        <title>Rendering Pipeline</title>
        <description>&lt;p&gt;The pipeline of Graphic Rendering includes 3 stages: Application Stage –&amp;gt; Geometry Stage –&amp;gt; Rasterization Stage.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;     
&lt;img src=&quot;/static/assets/img/blog/RenderingPipeline.png&quot; width=&quot;50%&quot; /&gt;
&lt;/p&gt;

&lt;hr /&gt;
&lt;h4 id=&quot;1-application-stage&quot;&gt;1. Application Stage&lt;/h4&gt;

&lt;p&gt;The start point of the rendering pipeline is CPU. In the Application Stage, the most important output is the geometry infomation which need to be rendered, called &lt;strong&gt;&lt;em&gt;Rendering Primitives.&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;In this Stage, the developer has 3 Tasks:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;prepare the environment and camera’s position. how many models are used in the environment, and which kinds of light sources are used in the scene.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;In order to improve the performance of rendering, need to do the work of &lt;strong&gt;&lt;em&gt;Culling&lt;/em&gt;&lt;/strong&gt;, to get rid of unnecessary rendering process.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Need to set up the rendering state of each model, such as the materials , textures, shaders.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;CPU will call &lt;strong&gt;&lt;em&gt;DrawCall()&lt;/em&gt;&lt;/strong&gt; to make GPU draw stuff on screen.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;For example.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p align=&quot;center&quot;&gt;     
&lt;img src=&quot;/static/assets/img/blog/applicationStage.png&quot; width=&quot;50%&quot; /&gt;
&lt;/p&gt;

&lt;hr /&gt;
&lt;h4 id=&quot;2-geometry-stage&quot;&gt;2. Geometry Stage&lt;/h4&gt;

&lt;p&gt;In Geometry Stage, the GPU will do the vertex operation through the received vertex data from the CPU.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;     
&lt;img src=&quot;/static/assets/img/blog/GeometryStage.png&quot; width=&quot;70%&quot; /&gt;
&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;The Process:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Vertex Shader: programmable , it is usually used to implement vertex space transformation, vertex shading and other functions.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Tesselation Shader: An optional shader for subdividing primitives (primitives are the basic units that make up an image, such as points, lines, surfaces, etc.).&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Geometry Shader: An optional shader for polygon shading operations.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Clipping: this phase is configurable. The goal of this phase is to trim away the vertices that are not in the camera’s field of view and to remove the facets of certain trig elements.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Screen Mapping: This stage is not configurable and is not programmatic; it is responsible for converting the coordinates of each pixel to the screen coordinate system.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;Meaning of_MVP (Model View Projection):&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The &lt;strong&gt;&lt;em&gt;vertices&lt;/em&gt;&lt;/strong&gt; of a model are stored in the &lt;strong&gt;&lt;em&gt;Object Space&lt;/em&gt;&lt;/strong&gt;. The &lt;strong&gt;&lt;em&gt;position&lt;/em&gt;&lt;/strong&gt; and the &lt;strong&gt;&lt;em&gt;orientation&lt;/em&gt;&lt;/strong&gt; of each model are stored in world space.&lt;/p&gt;

&lt;p&gt;Before an object can be rendered, its vertices must be transformed into the &lt;strong&gt;&lt;em&gt;Camera Space&lt;/em&gt;&lt;/strong&gt; (also called View Space).&lt;/p&gt;

&lt;p&gt;It is possible to transform vertices from object space directly into camera space by concatenating the matrices representing the transformations from object space to world space and from world space to camera space. The product of these transformations is called the &lt;strong&gt;&lt;em&gt;Model-View Trasnformation&lt;/em&gt;&lt;/strong&gt;.
Once a model’s vertices have been transformed into camera space, they will also do a projection transformation to apply &lt;strong&gt;&lt;em&gt;Perspective&lt;/em&gt;&lt;/strong&gt; (the geometry becomes smaller as the distance from the camera increases).&lt;/p&gt;

&lt;hr /&gt;
&lt;h4 id=&quot;3-rasterization-stage&quot;&gt;3. Rasterization Stage&lt;/h4&gt;

&lt;p&gt;In this stage, will use the data passed in the previous stage(Geometry stage) to produce pixels on the screen and render the final image.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;     
&lt;img src=&quot;/static/assets/img/blog/RasterizationStage.png&quot; width=&quot;70%&quot; /&gt;
&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;The Process:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;1) &lt;strong&gt;&lt;em&gt;Triangle Setup&lt;/em&gt;&lt;/strong&gt;: Differences in triangular surfaces and other relevant data are calculated. Fixed hardware operations to complete.&lt;/p&gt;

&lt;p&gt;2) &lt;strong&gt;&lt;em&gt;Triangle Traversal&lt;/em&gt;&lt;/strong&gt;: This stage checks whether each pixel is inside a triangle, and fragment is generated at this stage. Interpolation is usually used.&lt;/p&gt;

&lt;p&gt;3) &lt;strong&gt;&lt;em&gt;Fragment Shader&lt;/em&gt;&lt;/strong&gt;: Fully programmable. Use interpolated shading data as input and output one or more color values for the next phase. At this stage, GPU execution can be controlled by programming. The most commonly used technology in this stage is texture technology.&lt;/p&gt;

&lt;p&gt;4) &lt;strong&gt;&lt;em&gt;Per-Fragment Operation&lt;/em&gt;&lt;/strong&gt;: The Color value for each pixel is stored in the Color Buffer and merged at this stage. This stage is not completely programmable, but can be configured to produce different effects. In detail includes:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;a) &lt;strong&gt;&lt;em&gt;The pixel ownership&lt;/em&gt;&lt;/strong&gt; (the only one cannot be disabled): it simply determines whether a fragment lies in the region of the viewport that is currently visible on the display.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;b) &lt;strong&gt;&lt;em&gt;Scissor Test&lt;/em&gt;&lt;/strong&gt;: An application may specify a rectangle in the viewport, called the scissor rectangle, to which rendering should be restricted. Any fragments falling outside the scissor rectangle are discarded.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;c) &lt;strong&gt;&lt;em&gt;Alpha Test&lt;/em&gt;&lt;/strong&gt;: When the final color of a fragment is calculated, an application may also calculate an alpha value that usually represents the degree of transparency associated with the fragment. The alpha test compares the final alpha value of a fragment to a constant value that is preset by the application. The application can specifies what relationship between the two values (such as less than, greater than, or equal to) causes the test to pass. If the relationship is not satisfied, then the fragment is discarded.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;d) &lt;strong&gt;&lt;em&gt;Stencil Test&lt;/em&gt;&lt;/strong&gt;:  The sten- cil test reads the value stored in the stencil buffer at a fragment’s location and compares it to a value previously specified by the application. 
The stencil test passes only if a specific relationship is satisfied (e.g., the stencil value is equal to a particular value); otherwise, the stencil test fails, and the fragment is discarded.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;e) &lt;strong&gt;&lt;em&gt;Depth Test&lt;/em&gt;&lt;/strong&gt;: The depth Test compares the final depth associated with a fragment to the value currently residing in the depth buffer.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;f) &lt;strong&gt;&lt;em&gt;Blending&lt;/em&gt;&lt;/strong&gt;: Once the pixel ownership test, scissor test, alpha test, stencil test, and depth test have all passed, a fragment’s final color is blended into the &lt;strong&gt;&lt;em&gt;image buffer&lt;/em&gt;&lt;/strong&gt;. 
The blending operation calculates a new color by combining the fragment’s final color and the color already stored in the image buffer at the fragment’s location. The fragment’s alpha value and the alpha value stored in the image buffer may also be used to determine the color that ultimately appears in the viewport. 
The blending operation may be configured to simply replace the previous color in the image buffer, or it may produce special visual effects such as transparency.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;End –Cheng Gu&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

</description>
        <pubDate>Fri, 14 Sep 2018 00:00:00 -0700</pubDate>
        <link>http://localhost:4000/cg/2018/09/14/Rendering-Pipeline.html</link>
        <guid isPermaLink="true">http://localhost:4000/cg/2018/09/14/Rendering-Pipeline.html</guid>
        
        <category>CG</category>
        
        
        <category>Cg</category>
        
      </item>
    
      <item>
        <title>Lazy vs Eager Evalution</title>
        <description>&lt;p&gt;&lt;strong&gt;&lt;em&gt;Evaluation Strategies&lt;/em&gt;&lt;/strong&gt; are used by programming languages to determine when to evaluate the arguement(s) of a function call and what kind of value to pass to the function.&lt;/p&gt;

&lt;p&gt;For example, &lt;strong&gt;&lt;em&gt;Call By Value / Call By Reference&lt;/em&gt;&lt;/strong&gt; specifies that a function application evaluates the argument and to modify it through an assignment statement.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/assets/img/blog/Evaluations.png&quot; width=&quot;50%&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;
&lt;h4 id=&quot;1-lazy-evaluation&quot;&gt;1. Lazy Evaluation&lt;/h4&gt;

&lt;p&gt;In programming language theory, lazy evaluation, or &lt;strong&gt;&lt;em&gt;Call By Need&lt;/em&gt;&lt;/strong&gt; is an evaluation strategy which delays the evaluation of an expression &lt;strong&gt;&lt;em&gt;until its value is needed&lt;/em&gt;&lt;/strong&gt;(non-strict evaluation) and which also avoids repeated evaluations(sharing);&lt;/p&gt;

&lt;p&gt;The sharing can reduce the running time of certain functions by an exponential factor over other non-strict evaluation strategies, such as &lt;strong&gt;&lt;em&gt;Call By Name&lt;/em&gt;&lt;/strong&gt;.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Benefits:&lt;/p&gt;
  &lt;ol&gt;
    &lt;li&gt;The ability to define control flow(structures) as abstractions instead of primitives.&lt;/li&gt;
    &lt;li&gt;The ability to define potentially infinite data structures. This allows for more sraightforward implementation of some algorithms.&lt;/li&gt;
    &lt;li&gt;Performance increases by avoiding needless alculations and error conditions in evaluating compound expressions.&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Lazy evaluation&lt;/em&gt;&lt;/strong&gt; is often combined with memoization, as described in Jon Bentley’s Writing Efficient Programs. After a function’s value is computed for that parameter or set of parameters, the result is stored in a lookup table that is indexed by the values of those parameters; the next time the function is called, the table is consulted to determine whether the result for that combination of parameter values is already available. If so, the stored result is simply returned. If not, the function is evaluated and another entry is added to the lookup table for reuse.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Lazy Evaluation&lt;/em&gt;&lt;/strong&gt; can lead to reduction in memory footprint, since values are created when needed. However, lazy evaluation is difficult to combine with imperative features such as exception handling and input/output, because the order of operations becomes indeterminated. Lazy evaluation can introduce space leaks.&lt;/p&gt;

&lt;hr /&gt;
&lt;h4 id=&quot;2-eager-evaluation&quot;&gt;2. Eager Evaluation&lt;/h4&gt;

&lt;p&gt;In computer programming, eager evaluation, also known as strict evaluation or greedy evaluation, is the evaluation strategy used by most traditional programming languages. In eager evaluation, an expression is evaluated as soon as it is bound to a variable. An opposite alternative to eager evaluation is lazy evaluation, where expressions are evaluated only when a dependent expression is evaluated depending upon a defined evaluation strategy.&lt;/p&gt;

&lt;p&gt;Imperative programming languages, where the order of execution is implicitly defined by the structure of the source code, almost always use eager evaluation.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;The effects of eager evaluation include:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Code that is easily understandable in terms of execution order that does not potentially change its behaviour based on a change of execution context.
An easier debug process compared to other evaluation strategies due to the above.
Responsibility for code performance is however shifted towards the programmer, thus requiring a careful code optimisation process.&lt;/p&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;End –Cheng Gu&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

</description>
        <pubDate>Tue, 11 Sep 2018 00:00:00 -0700</pubDate>
        <link>http://localhost:4000/data%20structure/2018/09/11/Lazy-vs-Eager-Evaluation.html</link>
        <guid isPermaLink="true">http://localhost:4000/data%20structure/2018/09/11/Lazy-vs-Eager-Evaluation.html</guid>
        
        <category>Data Structure</category>
        
        
        <category>Data structure</category>
        
      </item>
    
      <item>
        <title>The Flag Attribute in Enumation</title>
        <description>&lt;p&gt;The problem with enumation is when you want to use conditional operator in your statement, you have to use bit operator.&lt;/p&gt;

&lt;p&gt;For example, you can’t use &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;amp;&amp;amp;&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;||&lt;/code&gt; operator, you have to use bit operator such as &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;amp;&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;|&lt;/code&gt;.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Bit Operator&lt;/p&gt;
&lt;/blockquote&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Operation&lt;/td&gt;
      &lt;td&gt;Description&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;a &amp;amp; b&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;if a = b = 1, the result is 1, else is 0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;a | b&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;if a and b as long as one of them is 1 then result is 1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;~a&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;if a = 1, the result = 0; if a = 0, the result = 1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;a ^ b&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Only when a = b, the result is 0; if a != b, the result is 1&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;hr /&gt;
&lt;h4 id=&quot;1-normal-way-to-use-enum-in-c&quot;&gt;1. Normal way to use enum in C#&lt;/h4&gt;

&lt;p&gt;if we want to create a new List Type. Ignore all other details, only focus on the iterator. This List will store the values in array, and this list can set the start point of the iteration. For example, we have 5 elements. We can set start index is 2, the iteration order shoule be 2,3,4,0,1.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;(1) create a enumation&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    public enum PersonType
    {
        Tall,  
        Rich,   
        Handsome,   
        White,
        Beauty
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;(2) Declare the enum and use switch case to do condition statement:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; public static PersonType person;
 {
        public static void Main(string[] args)
        {
            switch (person)
            {
                case PersonType.Tall:
                    Console.WriteLine(&quot;I'm Tall&quot;);
                    break;
                case PersonType.Rich:
                    Console.WriteLine(&quot;I'm Rich&quot;);
                    break;
                case PersonType.Handsome:
                    Console.WriteLine(&quot;I'm Handsome&quot;);
                    break;
                case PersonType.White:
                    Console.WriteLine(&quot;I'm White&quot;);
                    break;
                case PersonType.Beauty:
                    Console.WriteLine(&quot;I'm Beauty&quot;);
                    break;
                default:
                    break;
            }
        }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;
&lt;h4 id=&quot;2-problem&quot;&gt;2. Problem&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;so far, it’s fine. However if you want to have multiply choice such as&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    case PersonType.White | PersonType.Beauty:
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;It is still fine. No error at all. Then we try one more choice:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    case PersonType.White | PersonType.Handsome:
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote style=&quot;color: red&quot;&gt;
  &lt;p&gt;So now you will see an error! Why it will happen?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;
&lt;h4 id=&quot;3-solution&quot;&gt;3. Solution&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;Because when we create an enum the default value of it is&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    public enum PersonType
    {
        Tall = 0,       // 000000
        Rich = 1,       // 000001
        Handsome = 2,   // 000010   
        White = 3,      // 000011
        Beauty = 4      // 000100
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote style=&quot;color: red&quot;&gt;
  &lt;p&gt;So when the condition is &lt;code class=&quot;highlighter-rouge&quot;&gt;PersonType.White | PersonType.Beauty&lt;/code&gt;,   the comparison actually is &lt;code class=&quot;highlighter-rouge&quot;&gt;000011 | 000100 -&amp;gt; 000111&lt;/code&gt;,  there is no other duplicated address, so there is no error.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;However, when it comes to the comparison between &lt;code class=&quot;highlighter-rouge&quot;&gt;PersonType.White | PersonType.Handsome&lt;/code&gt;,  which actually is &lt;code class=&quot;highlighter-rouge&quot;&gt;000011 | 000010  -&amp;gt; 000011&lt;/code&gt;.  &lt;code class=&quot;highlighter-rouge&quot;&gt;000011&lt;/code&gt;  already has another value which is  &lt;code class=&quot;highlighter-rouge&quot;&gt;PersonType.White&lt;/code&gt;,  so it will give an error.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;So, how can we solve this problem?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;The right way is add a &lt;code class=&quot;highlighter-rouge&quot;&gt;[Flag]&lt;/code&gt; Attributes, And Change the value to 2^n, so that they will never meet each other&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    public enum PersonType
    {
        Tall = 1,       // 000001
        Rich = 2,       // 000010
        Handsome = 4,   // 000100   
        White = 8,      // 001000
        Beauty = 16     // 010000
    }
    
     public static PersonType person;
     {
        public static void Main(string[] args)
        {
            switch (person)
            {
                case PersonType.Tall:
                    Console.WriteLine(&quot;I'm Tall&quot;);
                    break;
                case PersonType.Rich:
                    Console.WriteLine(&quot;I'm Rich&quot;);
                    break;
                case PersonType.Handsome:
                    Console.WriteLine(&quot;I'm Handsome&quot;);
                    break;
                case PersonType.White:
                    Console.WriteLine(&quot;I'm White&quot;);
                    break;
                case PersonType.Beauty:
                    Console.WriteLine(&quot;I'm Beauty&quot;);
                    break;
                    
                // 001000 | 010000 -&amp;gt; 011000
                case PersonType.White | PersonType.Beauty: 
                    Console.WriteLine(&quot;I'm Beauty or white&quot;); 
                    break;
                // 001000 | 000100 -&amp;gt; 001100
                case PersonType.White | PersonType.Handsome:
                    Console.WriteLine(&quot;I'm white or handsome&quot;);
                    break;
                default:
                    break;
            }
        }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;End –Cheng Gu&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

</description>
        <pubDate>Tue, 04 Sep 2018 00:00:00 -0700</pubDate>
        <link>http://localhost:4000/csharp/2018/09/04/The-Flag-Attribute-in-Enumation.html</link>
        <guid isPermaLink="true">http://localhost:4000/csharp/2018/09/04/The-Flag-Attribute-in-Enumation.html</guid>
        
        <category>Csharp</category>
        
        
        <category>Csharp</category>
        
      </item>
    
      <item>
        <title>C# Iterator</title>
        <description>&lt;p&gt;Iterator can make you get all the elements in a sequence without caring about its type is &lt;strong&gt;&lt;em&gt;Array&lt;/em&gt;&lt;/strong&gt;, &lt;strong&gt;&lt;em&gt;List&lt;/em&gt;&lt;/strong&gt;, or other sequence structure.&lt;/p&gt;

&lt;p&gt;In .Net, Iterator is encapsulated by &lt;strong&gt;&lt;em&gt;IEnumerator&lt;/em&gt;&lt;/strong&gt; and their corresponding generic interfaces&lt;strong&gt;&lt;em&gt;IEnumerable&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;In C#1, it has already supported iterator, which is the &lt;strong&gt;&lt;em&gt;foreach&lt;/em&gt;&lt;/strong&gt; statement. Compared with using for loop to, many times using &lt;strong&gt;&lt;em&gt;foreach&lt;/em&gt;&lt;/strong&gt; will be more easy and strightforward. when doing &lt;strong&gt;&lt;em&gt;foreach&lt;/em&gt;&lt;/strong&gt;, the compiler will compile &lt;strong&gt;&lt;em&gt;foreach&lt;/em&gt;&lt;/strong&gt; to invoke the &lt;strong&gt;&lt;em&gt;GetEnumerator&lt;/em&gt;&lt;/strong&gt; and &lt;strong&gt;&lt;em&gt;MoveNext&lt;/em&gt;&lt;/strong&gt; methods, as well as the &lt;strong&gt;&lt;em&gt;Current&lt;/em&gt;&lt;/strong&gt; property.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;     
&lt;img src=&quot;/static/assets/img/blog/iterator.png&quot; width=&quot;80%&quot; /&gt;
&lt;/p&gt;

&lt;hr /&gt;
&lt;h4 id=&quot;1-c-10-implementing-iterators-manually&quot;&gt;1. C# 1.0: Implementing Iterators Manually&lt;/h4&gt;

&lt;p&gt;if we want to create a new List Type. Ignore all other details, only focus on the iterator. This List will store the values in array, and this list can set the start point of the iteration. For example, we have 5 elements. We can set start index is 2, the iteration order shoule be 2,3,4,0,1.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Main Program:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class MainClass
    {
        public static void Main(string[] args)
        {
            object[] values = { &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot; };
            IterationSample collection = new IterationSample(values, 2);
            foreach (object x in collection)
            {
                Console.WriteLine(x);
            }
        }
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;IterationSample Class:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; public class IterationSample : IEnumerable
    {
        public Object[] values;
        public Int32 startingPoint;

        public IterationSample(Object[] values, Int32 startingPoint)
        {
            this.values = values;
            this.startingPoint = startingPoint;
        }

        // In order to use &quot;foreach&quot; statement, this method is necessary
        public IEnumerator GetEnumerator()
        {
            return new IterationSampleEnumerator(this);
        }
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;In above code, we implemented IEnumerable Interface, but we haven’t implement the GetEnumerator() method. We can use this &lt;strong&gt;&lt;em&gt;IterationSample&lt;/em&gt;&lt;/strong&gt; class to implement the Ienumerator Interface, and use different functions implements the Iterator’s Logics, but this goes against the principle of single responsibility. So we use another class to implement this.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; public class IterationSampleEnumerator : IEnumerator
    {
        IterationSample parent;//object to iterate
        Int32 position;// currentIndex Position
        internal IterationSampleEnumerator(IterationSample parent)
        {
            this.parent = parent;
            position = -1;
        }

        public bool MoveNext()
        {
            //determine the current position if the last index in the list
            if (position != parent.values.Length) 
            {
                position++;
            }
            return position &amp;lt; parent.values.Length;
        }

        public object Current
        {
            get
            {
                //not allow to access the first and the last value
                if (position == -1 || position == parent.values.Length)
                {
                    throw new InvalidOperationException();
                }
                
                // consider the case of custom start position 
                Int32 index = position + parent.startingPoint;
                index = index % parent.values.Length;
                return parent.values[index];
            }
        }

        public void Reset()
        {
            position = -1;
        }
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;
&lt;h4 id=&quot;2-c-20-implementing-iterators&quot;&gt;2. C# 2.0: Implementing Iterators&lt;/h4&gt;

&lt;p&gt;After C# 2.0, it introduced &lt;strong&gt;&lt;em&gt;iterator&lt;/em&gt;&lt;/strong&gt;, and &lt;strong&gt;&lt;em&gt;yield return&lt;/em&gt;&lt;/strong&gt; statements. It becomes much more simplier.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Main Program:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class MainClass
    {
        public static void Main(string[] args)
        {
            object[] values = { &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot; };
            IterationSample collection = new IterationSample(values, 2);
            foreach (object x in collection)
            {
                Console.WriteLine(x);
            }
        }
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;IterationSample Class:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; public class IterationSample : IEnumerable
    {
        public Object[] values;
        public Int32 startingPoint;

        public IterationSample(Object[] values, Int32 startingPoint)
        {
            this.values = values;
            this.startingPoint = startingPoint;
        }

        // In order to use &quot;foreach&quot; statement, this method is necessary
        public IEnumerator GetEnumerator()
        {
            for (int index = 0; index &amp;lt; this.values.Length; index++)
            {
                yield return values[(index + startingPoint) % values.Length];
            }   
        }
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;End –Cheng Gu&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

</description>
        <pubDate>Tue, 28 Aug 2018 00:00:00 -0700</pubDate>
        <link>http://localhost:4000/csharp/2018/08/28/CSharp-Iterator.html</link>
        <guid isPermaLink="true">http://localhost:4000/csharp/2018/08/28/CSharp-Iterator.html</guid>
        
        <category>Csharp</category>
        
        
        <category>Csharp</category>
        
      </item>
    
      <item>
        <title>Unity Rendering Path</title>
        <description>&lt;p&gt;Unity support many kinds of rendering path. In Unity 5.0, there are three types of rendering path: forward, deferred, and vertex lit rendering path.&lt;/p&gt;

&lt;hr /&gt;
&lt;h4 id=&quot;1-forward-rendering-path&quot;&gt;1. Forward Rendering Path&lt;/h4&gt;

&lt;p align=&quot;center&quot;&gt;     
&lt;img src=&quot;/static/assets/img/blog/fwdRendering.png&quot; width=&quot;80%&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;For each forward rendering, we need to render the rendering primitive of the object and calculate the data of two buffers (color buffer and depth buffer). We use the depth buffer to determine if a fragment is visible and update the color value of the color buffer if it is visible.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;We can use pseudo code to describe the process of forward rendering:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Pass
{
    for(each primitive in this model)
    {
        for(each fragment covered by this primitive)
        {
            if(failed in depth test)
            {
                discard;
            }
            else
            {
                float4 color = Shading(materialInfo, pos, normal, lightDir, viewDir);

                WriteFrameBuffer(fragment, color);
            }
        }
    }
} 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;
&lt;h4 id=&quot;2-deferred-rendering-path&quot;&gt;2. Deferred Rendering Path&lt;/h4&gt;

&lt;p align=&quot;center&quot;&gt;     
&lt;img src=&quot;/static/assets/img/blog/deferredrendering.png&quot; width=&quot;80%&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;Deferred Rendering mainly includes two Pass. The first Pass, we don’t do any lighting calculations, and only calculate which fragment in the screen is visible, by depth buffer. After finding a fragment is visible, it will store the data into the G-Buffer. Then, in the second Pass, it will use the data of fragment in the G-Buffer to do the lighting calculation.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;We can use pseudo code to describe the process of the deferred rendering:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;PassOne // Store fragment data into G-Buffer
{
    for(each primitive in this model)
    {
        for(each fragment covered by this primitive)
        {
            if(failed in depth test)
            {
                discard;
            }
            else
            {
                WriteGBuffer(materialInfo, pos, normal, lightDir, viewDir);
            }
        }
    }
}
PassTwo // Calcaulate Lighting by using the data in G-Buffer
{
    for(each pixel in the screen)
    {
        if(the pixel is valid)
        {
            readGBuffer(pixel, materialInfo, pos, normal, lightDir, viewDir);
            float4 color = Shading(materialInfo, pos, normal, lightDir, viewDir);
            WriteFrameBuffer(pixel, color);
        }
    }
} 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;
&lt;h4 id=&quot;2-why-use-deferred-rendering&quot;&gt;2. Why use Deferred Rendering&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;Normally we will use Forward Rendering, but when the scene has too many light sources, the performance of Forward Rendering drops dramatically.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;For example, if we place multiple light sources in an area in the Unity Scene, and these light source areas overlap and influence with each other. In order to get the final lighting effects, we need to perform multiple Pass for each object in the area to calculate the lighting result of different light source to this object, finally, blend these results in the color buffer to get the final lighting. Therefore, every time when we call a Pass we need to render the object again, but many calculations actually is repeat.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote style=&quot;color: red&quot;&gt;
  &lt;p&gt;Deferred Rendering can solve this problem because it not only uses color buffer, and depth buffer, it also use an additional buffer called G-Buffer (Geometry- Buffer). G-Buffer stores the information of the surface we care (normally it means the surface which is the closest to camera), such as the surface’s Normal, Position, Material Properties used for illumination calculation, etc.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;End –Cheng Gu&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

</description>
        <pubDate>Tue, 14 Aug 2018 00:00:00 -0700</pubDate>
        <link>http://localhost:4000/unity/cg/2018/08/14/Unity-Rendering-Path.html</link>
        <guid isPermaLink="true">http://localhost:4000/unity/cg/2018/08/14/Unity-Rendering-Path.html</guid>
        
        <category>Unity</category>
        
        <category>CG</category>
        
        
        <category>Unity</category>
        
        <category>Cg</category>
        
      </item>
    
      <item>
        <title>Union Find Algorithm</title>
        <description>&lt;p&gt;This article focuses on an algorithm for solving problems such as dynamic connectivity, using a data structure called Union Find.&lt;/p&gt;

&lt;p&gt;The Evolutionary history of Union Find is From Quick Find –&amp;gt; Union Find –&amp;gt; Weighted Union Find&lt;/p&gt;

&lt;blockquote style=&quot;color: red&quot;&gt;
  &lt;p&gt;This is the Performance consumption table:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p align=&quot;center&quot;&gt;     
&lt;img src=&quot;/static/assets/img/blog/Performance consumption table.png&quot; width=&quot;50%&quot; /&gt;
&lt;/p&gt;

&lt;hr /&gt;
&lt;h4 id=&quot;dynamic-connectivity-client&quot;&gt;Dynamic-Connectivity Client&lt;/h4&gt;
&lt;blockquote&gt;
  &lt;p&gt;Code:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static void main(String[] args)
{
    int N = StdIn.readInt();
    UF uf = new UF(N);
    while (!StdIn.isEmpty())
    {
        int p = StdIn.readInt();    
        int q = StdIn.readInt();
        if (!uf.connected(p, q))
        {
            uf.union(p, q);
            StdOut.println(p + &quot; &quot; + q);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;
&lt;h4 id=&quot;quick-find&quot;&gt;Quick Find&lt;/h4&gt;

&lt;p align=&quot;center&quot;&gt;     
&lt;img src=&quot;/static/assets/img/blog/qf.png&quot; width=&quot;70%&quot; /&gt;
&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Code:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class QuickFindUF
{
    private int[] id;
    private int count;
    public QuickFindUF(int N)
    {
        id = new int[N];
        count =N;
        // Set ID of earch object to itself
        for (int i = 0; i &amp;lt; N; i++)
            id[i] = i;
    }
    
    // check if p and q are in the same component
    public boolean connected(int p, int q)
    { 
        return id[p] == id[q]; 
    }
    
    // find the id for the given index
    public int find(int p)
    {
        return id[p]; 
    }
    
    public int count()
    {
        return count;
    }

    // change all id[p] to id[q]
    public void union(int p, int q)
    {
        int pid = id[p];
        int qid = id[q];
       
        for (int i = 0; i &amp;lt; id.length; i++)
            if (id[i] == pid) id[i] = qid;
        count--;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;
&lt;h4 id=&quot;quick-union&quot;&gt;Quick Union&lt;/h4&gt;

&lt;p align=&quot;center&quot;&gt;     
&lt;img src=&quot;/static/assets/img/blog/uf.png&quot; width=&quot;70%&quot; /&gt;
&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Code:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class QuickUnionUF
{
    private int[] id;
    private int count;
    public QuickUnionUF(int N)
    {
        id = new int[N];
        count =N;
        // Set ID of earch object to itself
        for (int i = 0; i &amp;lt; N; i++)
            id[i] = i;
    }
    
    // check if p and q have same root
    public boolean connected(int p, int q)
    { 
        return root(p) == root(q); 
    }
    
    // find the id for the given index
    public int find(int i)
    {
        return id[i]; 
    }
    
    public int root(int i)
    {
        //chase parent pointers until reach root
        while(i!=id[i])
        {
            // Make every other node in path point to its grandparent
            id[i] = id[id[i]]; // Pass Compression
            
            i = id[i];
        }
        return i;
    }
    
    public int count()
    {
        return count;
    }
    
    // change all id[p] to id[q]
    public void union(int p, int q)
    {
        int pRoot = root(p);
        int qRoot = root(q);
        
        if(pRoot == qRoot) return;
        id[pRoot] = qRoot; // change root of p to point to root of q
        count--;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;weighted-quick-union&quot;&gt;Weighted Quick Union&lt;/h4&gt;

&lt;p align=&quot;center&quot;&gt;     
&lt;img src=&quot;/static/assets/img/blog/wuf.png&quot; width=&quot;70%&quot; /&gt;
&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Code:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class WeightedQuickUnionUF
{
    private int[] id;
    private int[] size; // to count number of objs in the each root
    private int count;
    public WeightedQuickUnionUF(int N)
    {
        id = new int[N];
        size = new int[N];
        count = N;
        // Set ID of earch object to itself
        for (int i = 0; i &amp;lt; N; i++)
            id[i] = i;
    }
    
    // check if p and q have same root
    public boolean connected(int p, int q)
    { 
        return root(p) == root(q); 
    }
    
    // find the id for the given index
    public int find(int i)
    {
        return id[i]; 
    }
    
    public int root(int i)
    {
        //chase parent pointers until reach root
        while(i!=id[i])
        {
            // Make every other node in path point to its grandparent
            id[i] = id[id[i]]; // Pass Compression
                        
            i = id[i];
        }
        return i;
    }
    
    public int count()
    {
        return count;
    }
    
    // change all id[p] to id[q]
    public void union(int p, int q)
    {
        int pRoot = root(p);
        int qRoot = root(q);
        
        if(pRoot == qRoot) return;
        
        // Link root of smaller tree to root of larger tree
        if(size[pRoot] &amp;lt; size[qRoot])
        {
            id[qRoot] = pRoot;// change root of q to point to root of p
            size[pRoot] += size[qRoot]; // update the tree size
        }
        else
        {
            id[pRoot] = qRoot;// change root of p to point to root of q
            size[qRoot] += size[pRoot]; // update the tree size
        }
        count--;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;comparsion-between-if-it-is-weighted-or-not&quot;&gt;Comparsion between if it is Weighted or not&lt;/h4&gt;

&lt;p align=&quot;center&quot;&gt;     
&lt;img src=&quot;/static/assets/img/blog/uf vs wuf.png&quot; width=&quot;80%&quot; /&gt;
&lt;/p&gt;
&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;End –Cheng Gu&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

</description>
        <pubDate>Thu, 09 Aug 2018 00:00:00 -0700</pubDate>
        <link>http://localhost:4000/data%20structure/csharp/2018/08/09/Union-Find-Algorithm.html</link>
        <guid isPermaLink="true">http://localhost:4000/data%20structure/csharp/2018/08/09/Union-Find-Algorithm.html</guid>
        
        <category>Data Structure</category>
        
        <category>Java</category>
        
        
        <category>Data structure</category>
        
        <category>Csharp</category>
        
      </item>
    
      <item>
        <title>X-Ray Effect in Shader</title>
        <description>&lt;p&gt;In many games, we can use special ability to see through the wall. So In this post I am going to make a X-ray effect.&lt;/p&gt;

&lt;p&gt;A X-Ray is easy to achieve. basicly, just need to add an additional &lt;code class=&quot;highlighter-rouge&quot;&gt;Pass{}&lt;/code&gt; in shader which the &lt;strong&gt;&lt;em&gt;ZTest&lt;/em&gt;&lt;/strong&gt; should set to &lt;strong&gt;&lt;em&gt;Greater&lt;/em&gt;&lt;/strong&gt;, and the ZWrite should close.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;This is the result of the experiment:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p align=&quot;center&quot;&gt;     
&lt;img src=&quot;/static/assets/img/blog/X-Ray.gif&quot; width=&quot;50%&quot; /&gt;
&lt;/p&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Code:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Shader &quot;MyShader/Transparent2&quot;
{
	Properties
	{
        _MainTex(&quot;MainTex&quot;,2D) = &quot;&quot;{}
        _Color(&quot;Color&quot;, Color) = (1,1,1,1)
        _OccPower(&quot;Occlusion Power&quot;, Range(0,2)) = 0.5 
        _OccColor(&quot;Occlusion Color&quot;, Color) = (1,1,1,1)
	}
	SubShader
	{
        Tags{&quot;RenderTyoe&quot; = &quot;Transparent&quot; &quot;Queue&quot; = &quot;Transparent&quot;}
        
		Pass //  This pass is for X-ray
		{
            Blend DstAlpha One 

            // When the Z value of the object's pixel is greater 
            //than the Z value of the current camera on the pixel, it will pass Ztest
            ZTest Greater

            ZWrite Off
			CGPROGRAM
			#pragma vertex vert
            #pragma fragment frag
			
			#include &quot;UnityCG.cginc&quot;

            float _OccPower;
            fixed4 _OccColor;

			struct appdata
			{
				float4 vertex : POSITION;
                float3 normal : NORMAL;

			};

			struct v2f
			{
                float3 worldNormal : TEXCOORD0;
                float4 pos : SV_POSITION;
                float4 worldVertex : TEXCOORD1;
			};
            


			v2f vert (appdata v)
			{
				v2f o;
				o.pos = UnityObjectToClipPos(v.vertex);
                o.worldNormal = normalize(mul(v.normal,unity_WorldToObject));
                o.worldVertex = normalize(mul(unity_ObjectToWorld, v.vertex));
                
				return o;
			}
			
			fixed4 frag (v2f i) : SV_Target
			{

                float3 viewDir = normalize(_WorldSpaceCameraPos.xyz - i.worldVertex.xyz);

                // rim effect
                float rim = 1-saturate(dot(i.worldNormal,viewDir));

				fixed3 col = pow(rim, _OccPower) * _OccColor.rgb;

				return fixed4(col,0.5f);
			}
			ENDCG
		}



        Pass // This pass is for the model itself
        {
            Blend SrcAlpha OneMinusSrcAlpha
            ZWrite On
            ZTest LEqual 
            CGPROGRAM
            #pragma vertex vert
            #pragma fragment frag
            
            #include &quot;UnityCG.cginc&quot;

            struct appdata
            {
                float4 vertex : POSITION;
                float2 uv : TEXCOORD0;
            };

            struct v2f
            {
                float2 uv : TEXCOORD0;
                float4 vertex : SV_POSITION;
            };

            sampler2D _MainTex;
            float4 _MainTex_ST;
            fixed4 _Color;
            
            v2f vert (appdata v)
            {
                v2f o;
                o.vertex = UnityObjectToClipPos(v.vertex);
                o.uv = TRANSFORM_TEX(v.uv, _MainTex);
                return o;
            }
            
            fixed4 frag (v2f i) : SV_Target
            {
                // sample the texture
                fixed3 col = tex2D(_MainTex, i.uv).rgb * _Color.rgb;

                return fixed4(col,1);
            }
            ENDCG
        }
	}
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;End –Cheng Gu&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

</description>
        <pubDate>Sun, 05 Aug 2018 00:00:00 -0700</pubDate>
        <link>http://localhost:4000/cg/unity/2018/08/05/X-Ray-Effect-in-Shader.html</link>
        <guid isPermaLink="true">http://localhost:4000/cg/unity/2018/08/05/X-Ray-Effect-in-Shader.html</guid>
        
        <category>Unity</category>
        
        <category>Shader</category>
        
        <category>Math</category>
        
        <category>CG</category>
        
        
        <category>Cg</category>
        
        <category>Unity</category>
        
      </item>
    
      <item>
        <title>Partial Derivative in Shader</title>
        <description>&lt;p&gt;Currently found a post talked about ddx, and ddy function in shader, so here is a conclusion from that post, and some examples.&lt;/p&gt;

&lt;p&gt;This is the &lt;a href=&quot;http://www.aclockworkberry.com/shader-derivative-functions/#footnote_3_1104&quot;&gt;Reference Link&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;
&lt;h4 id=&quot;partial-derivativeddxddy&quot;&gt;Partial Derivative(ddx,ddy)&lt;/h4&gt;
&lt;p&gt;In Shader Language, The partial derivative functions are divided into HLSL: ddx and ddy; GLSL:dFdx and dFdy, respectively corresponding to the change rate of various variables in the pixel block in the screen space on the x and y axes.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;     
&lt;img src=&quot;/static/assets/img/blog/glslPartialDerivative.png&quot; width=&quot;50%&quot; /&gt;
&lt;/p&gt;

&lt;p style=&quot;color: red&quot;&gt;This image illustrates the calculation of Partial Derivative.&lt;/p&gt;

&lt;p&gt;As We know, during the Rasterization, GPUs will run many Fragment shaders in parallel at the same time, but it is not performed pixel by pixel, but by organizing them into a group of pixels at 2x2 pixels to execute in parallel. And the partial derivative is exactly the rate of change in this pixel. It can be seen from the figure above that ddx() is the value of the pixel block on the right minus the value of the pixel block on the left, while ddy is the value of the pixel block below minus the value of the pixel block above. Where x and y represent screen coordinates.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Notices: Partial derivative ddx / ddy can calculate any variable in Fragment Shader. such as Vectors, matrices and so on.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;
&lt;h4 id=&quot;example-1-derivatives-and-mipmaps-for-uv&quot;&gt;Example 1: Derivatives and mipmaps (For UV)&lt;/h4&gt;

&lt;p align=&quot;center&quot;&gt;     
&lt;img src=&quot;/static/assets/img/blog/mipmap.png&quot; width=&quot;70%&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;In 3D world, the size of image is related to the location of the camera. When it is close to the camera, the actual pixel of the picture is bigger; when it is far away from the camera, the actual pixel of the picture is smaller. For example, a 64x64 image may show 50&lt;em&gt;50 pixels when it is close to the camera; when it is far away, it may only show 20&lt;/em&gt;20 pixels. So, if the texture pixel is always the orginal number, when it is far away from the camera, this will lead to performance waste.&lt;/p&gt;

&lt;p&gt;Mipmap texture Technology is currnetly the most effective way to solve the relationship between texture resolution and the distance between view points. it will first compress images into many progressively smaller images.&lt;/p&gt;

&lt;p&gt;“Derivatives are used during texture sampling to select the best mipmap level. The rate of variation of the texture coordinates with respect to the screen coordinates is used to choose a mipmap; the larger the derivatives, the greater the mipmap level (and the lesser the mipmap size).”&lt;/p&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;example-2-face-normal-computation--flat-shaderfor-vertex&quot;&gt;Example 2: Face normal computation / Flat Shader(For vertex)&lt;/h4&gt;

&lt;p&gt;Derivatives can be used to compute the current triangle’s face normal in a fragment shader. The horizontal and vertical derivatives of the current fragment’s world-position are two vectors laying in the triangle’s surface. Their cross product is a vector orthogonal to the surface and its norm is the triangle’s normal vector (see the 3d model below).&lt;/p&gt;

&lt;p&gt;Particular attention must be paid to the ordering of the cross product: being the OpenGL coordinate system left-handed (at least when working in window space which is the context where the fragment shader works) and being the horizontal derivative vector always oriented right and the vertical down, the ordering of the cross product to obtain a normal vector oriented toward the camera is horizontal x vertical (more about cross products and basis orientations in this article).&lt;/p&gt;

&lt;p&gt;The interactive model below shows the link between screen pixels and fragmets over a triangle surface being rasterized, the derivative vectors on the surface (in red and green), and the normal vector (in blue) obtained by the cross product of the twos.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;     
&lt;img src=&quot;/static/assets/img/blog/fs1.png&quot; width=&quot;70%&quot; /&gt;
&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;The normal is shown in Unity shaderlab as follows&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p align=&quot;center&quot;&gt;     
&lt;img src=&quot;/static/assets/img/blog/fs2.png&quot; width=&quot;60%&quot; /&gt;
&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void surf (Input IN, inout SurfaceOutput o)
{
    o.Albedo = normalize(cross(ddy(IN.worldPos),ddx(IN.worldPos)));
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;example-3-sharpen-edge-for-texture&quot;&gt;Example 3: Sharpen Edge (For Texture)&lt;/h4&gt;

&lt;p align=&quot;center&quot;&gt;     
&lt;img src=&quot;/static/assets/img/blog/es.png&quot; width=&quot;70%&quot; /&gt;
&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void surf (Input IN, inout SurfaceOutput o)
{
    half4 c = tex2D(_MainTex, IN.uv_MainTex);
    
    //The comparsion is depends on this
    //c += ddx(c)*2 + ddy(c)*2; 
    o.Albedo = c.rgb;
    o.Alpha = c.a;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;example-4-blur-image-except-the-pixels-which-are-facing-towards-camera&quot;&gt;Example 4: Blur image except the pixels which are facing towards camera&lt;/h4&gt;

&lt;p align=&quot;center&quot;&gt;     
&lt;img src=&quot;/static/assets/img/blog/Blur.gif&quot; width=&quot;70%&quot; /&gt;
&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Shader &quot;MyShader/SimpleBlur&quot;
{
	Properties
	{
		_MainTex (&quot;Texture&quot;, 2D) = &quot;white&quot; {}
	}
	SubShader
	{
		Tags { &quot;RenderType&quot;=&quot;Opaque&quot; }

		Pass
		{
			CGPROGRAM
			#pragma vertex vert
			#pragma fragment frag

			#include &quot;UnityCG.cginc&quot;

			struct appdata
			{
				float4 vertex : POSITION;
				float2 texcoord : TEXCOORD0;
			};

			struct v2f
			{
                float4 pos : SV_POSITION;
				float2 uv : TEXCOORD0;
                float z : TEXCOORD1;
			};

			sampler2D _MainTex;
			
			v2f vert (appdata v)
			{
				v2f o;
				o.pos = UnityObjectToClipPos(v.vertex);
                
                o.uv = v.texcoord.xy;
                o.z = mul(unity_ObjectToWorld, v.vertex).z;
				return o;
			}
			
			fixed4 frag (v2f i) : SV_Target
			{
                float2 dsdx = ddx(i.z)*10;
                float2 dsdy = ddy(i.z)*10;

				fixed4 col = tex2D(_MainTex, i.uv, dsdx, dsdy);

				return col;
			}
			ENDCG
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;End –Cheng Gu&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

</description>
        <pubDate>Fri, 03 Aug 2018 00:00:00 -0700</pubDate>
        <link>http://localhost:4000/cg/unity/2018/08/03/Partial-Derivative-in-Shader.html</link>
        <guid isPermaLink="true">http://localhost:4000/cg/unity/2018/08/03/Partial-Derivative-in-Shader.html</guid>
        
        <category>Unity</category>
        
        <category>Shader</category>
        
        <category>Math</category>
        
        <category>CG</category>
        
        
        <category>Cg</category>
        
        <category>Unity</category>
        
      </item>
    
      <item>
        <title>Dynamic Discoloration Shader</title>
        <description>&lt;p&gt;An exercise of writing surface shader with vertex function to achieve dynamic discoloration of the model and cube map reflection.&lt;/p&gt;

&lt;hr /&gt;

&lt;p align=&quot;center&quot;&gt;     
&lt;img src=&quot;/static/assets/img/blog/Model Dynamic Discoloration.gif&quot; width=&quot;70%&quot; /&gt;
&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Shader &quot;MyShader/CarPaint_SurfaceShader&quot; 
{
	Properties 
    {
        _MainColor(&quot;MainColor&quot;,Color) = (1,1,1,1)
        _SecondColor(&quot;SecondColor&quot;,Color) = (1,1,1,1)
        _Center(&quot;Center&quot;,Range(-0.7,0.7)) = 0
        _Radius(&quot;R&quot;, Range(0,0.5)) = 0.2
		_Glossiness (&quot;Smoothness&quot;, Range(0,1)) = 0.5
		_Metallic (&quot;Metallic&quot;, Range(0,1)) = 0.0
        _MainTex(&quot;Main Texture&quot;,2D) = &quot;&quot;{}
        _CubeMap(&quot;Cube Map&quot;,Cube)=&quot;&quot;{}
    }
	SubShader {
		Tags { &quot;RenderType&quot;=&quot;Opaque&quot; }

		CGPROGRAM

		// Physically based Standard lighting model, and enable shadows on all light types
		#pragma surface surf Standard fullforwardshadows vertex:vert
        
        #pragma target 3.5 // needs it for dx 11

        float4 _MainColor;
        float4 _SecondColor;
        float _Center;
        float _Radius;
        half _Glossiness;
        half _Metallic;
		sampler2D _MainTex;
        samplerCUBE _CubeMap;

		struct Input 
        {
			float2 uv_MainTex;
            float3 R;
            float z;
		};

        void vert(inout appdata_full v, out Input o)
        {
            // UNITY_INITIALIZE_OUTPUT(Input,o);
            // or
            o.uv_MainTex = v.texcoord.xy;

            float3 V = -WorldSpaceViewDir(v.vertex);
            // float3 V = mul(_Object2World,v.vertex).xyz - _WorldSpaceCameraPos.xyz;
            // or
            float3 N = normalize(mul(v.normal,(float3x3)unity_WorldToObject));

            o.R = reflect(V,N);
            o.z = v.vertex.z;// determine the direction the lerp
        }
        

		void surf (Input IN, inout SurfaceOutputStandard o) {
			// Albedo comes from a texture tinted by color
			fixed4 c = tex2D (_MainTex, IN.uv_MainTex);
            fixed4 cubeMapCol = texCUBE(_CubeMap,IN.R);

            // Combine texture color and the cubemap reflection color
			o.Albedo = c.rgb + cubeMapCol.rgb;

			// Metallic and smoothness come from slider variables
			o.Metallic = _Metallic;
			o.Smoothness = _Glossiness;
			o.Alpha = c.a;


            float d = IN.z - _Center;
            float dLength = abs(d);
            
            // Get 1 or -1 to determine the color on two sides
            // the vertices &amp;gt; _Center, it will be 1
            // the vertices &amp;lt; _Center, it will be -1
            d = d / dLength;

            // The pure level represents the _MainColor and _SecondColor value
            // when the pureLevel increase, the blending between two color will increase
            float pureLevel = dLength /_Radius;
            pureLevel = saturate(pureLevel);

            // This determine the negative or positive value
            d *= pureLevel;

            d = d * 0.5+0.5;

            o.Albedo *= lerp(_MainColor, _SecondColor, d);

		}
		ENDCG
	}
	FallBack &quot;Diffuse&quot;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;End –Cheng Gu&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

</description>
        <pubDate>Sun, 29 Jul 2018 00:00:00 -0700</pubDate>
        <link>http://localhost:4000/cg/unity/2018/07/29/Dynamic-Discoloration-Shader.html</link>
        <guid isPermaLink="true">http://localhost:4000/cg/unity/2018/07/29/Dynamic-Discoloration-Shader.html</guid>
        
        <category>Unity</category>
        
        <category>Shader</category>
        
        <category>Math</category>
        
        <category>CG</category>
        
        
        <category>Cg</category>
        
        <category>Unity</category>
        
      </item>
    
      <item>
        <title>OPP Design Principles</title>
        <description>&lt;p&gt;For making our code system more stable and portability, esay to maintain, follow the solid design principle is significant.&lt;/p&gt;

&lt;hr /&gt;
&lt;h4 id=&quot;1-srp-single-responsibility-principle&quot;&gt;1. SRP (Single Responsibility Principle)&lt;/h4&gt;

&lt;p align=&quot;center&quot;&gt;     
&lt;img src=&quot;/static/assets/img/blog/SRP1.png&quot; width=&quot;40%&quot; /&gt;
&lt;img src=&quot;/static/assets/img/blog/SRP2.png&quot; width=&quot;40%&quot; /&gt;
&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;&lt;em&gt;The single responsibility principle (SRP)&lt;/em&gt;&lt;/strong&gt; states that every module or class should have responsibility over a single part of the functionality provided by the software, which means: “When designing to encapsulate a class, the class should be responsible for one kind of function, and all its services should be narrowly aligned with that responsibility”.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;
&lt;h4 id=&quot;2-ocp-open-closed-principle&quot;&gt;2. OCP (Open-Closed Principle)&lt;/h4&gt;

&lt;p align=&quot;center&quot;&gt;     
&lt;img src=&quot;/static/assets/img/blog/OCP.jpg&quot; width=&quot;70%&quot; /&gt;
&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;&lt;em&gt;The open/closed principle&lt;/em&gt;&lt;/strong&gt; states “software entities (classes, modules, functions, etc.) should be open for extension, but closed for modification”; that is such an entity can allow its behaviour to be extended without modifying its source code.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;The name open/closed principle has been used in two ways. Both ways use generalizations (for instance, inheritance or delegate functions) to resolve the apparent dilemma, but the goals, techniques, and results are different.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;3-lsp-liskov-substitution-principle&quot;&gt;3. LSP (Liskov Substitution Principle)&lt;/h4&gt;

&lt;p align=&quot;center&quot;&gt;     
&lt;img src=&quot;/static/assets/img/blog/LSP.jpg&quot; width=&quot;60%&quot; /&gt;
&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Substitutability is a principle in object-oriented programming stating that “A subclass must be able to replace the parent class. “&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;For example: There are 3 Classes, Employee, Artist, Programmer. Both Artist and Programmer are the employee, so they should be inherit from Employee Class&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;4-dip-dependence-inversion-principle&quot;&gt;4. DIP (Dependence Inversion Principle)&lt;/h4&gt;

&lt;p align=&quot;center&quot;&gt;     
&lt;img src=&quot;/static/assets/img/blog/DIP.png&quot; width=&quot;60%&quot; /&gt;
&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;The principle states:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;High-level modules should not depend on low-level modules. Both should depend on abstractions.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Abstractions should not depend on details. Details should depend on abstractions.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;5-isp-interface-segregation-principle&quot;&gt;5. ISP (Interface Segregation Principle)&lt;/h4&gt;

&lt;p align=&quot;center&quot;&gt;     
&lt;img src=&quot;/static/assets/img/blog/ISP.jpg&quot; width=&quot;50%&quot; /&gt;
&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;The interface-segregation principle (ISP) states that: “No client should be forced to depend on methods it does not use. “&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;ISP splits interfaces that are very large into smaller and more specific ones so that clients will only have to know about the methods that are of interest to them. Such shrunken interfaces are also called role interfaces. ISP is intended to keep a system decoupled and thus easier to refactor, change, and redeploy. ISP is one of the five SOLID principles of object-oriented design, similar to the High Cohesion Principle of GRASP.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;6-lkp-least-knowledge-principle&quot;&gt;6. LKP (Least Knowledge Principle)&lt;/h4&gt;

&lt;p align=&quot;center&quot;&gt;     
&lt;img src=&quot;/static/assets/img/blog/LKP.jpg&quot; width=&quot;50%&quot; /&gt;
&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;The principle states:&lt;/p&gt;
  &lt;ol&gt;
    &lt;li&gt;Each unit should have only limited knowledge about other units: only units “closely” related to the current unit.&lt;/li&gt;
    &lt;li&gt;Each unit should only talk to its friends; don’t talk to strangers.&lt;/li&gt;
    &lt;li&gt;Only talk to your immediate friends.&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;7-composition-over-inheritance&quot;&gt;7. Composition over inheritance&lt;/h4&gt;

&lt;p align=&quot;center&quot;&gt;     
&lt;img src=&quot;/static/assets/img/blog/COI.png&quot; width=&quot;70%&quot; /&gt;
&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;To favor composition over inheritance is a design principle that gives the design higher flexibility. It is more natural to build business-domain classes out of various components than trying to find commonality between them and creating a family tree&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Initial design is simplified by identifying system object behaviors in separate interfaces instead of creating a hierarchical relationship to distribute behaviors among business-domain classes via inheritance. This approach more easily accommodates future requirements changes that would otherwise require a complete restructuring of business-domain classes in the inheritance model. Additionally, it avoids problems often associated with relatively minor changes to an inheritance-based model that includes several generations of classes.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;End –Cheng Gu&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

</description>
        <pubDate>Fri, 20 Jul 2018 00:00:00 -0700</pubDate>
        <link>http://localhost:4000/csharp/python/javascript/2018/07/20/OPP-Programming-Common-Design-Pattern.html</link>
        <guid isPermaLink="true">http://localhost:4000/csharp/python/javascript/2018/07/20/OPP-Programming-Common-Design-Pattern.html</guid>
        
        <category>Unity</category>
        
        <category>Csharp</category>
        
        <category>Math</category>
        
        <category>CG</category>
        
        <category>Game Dev</category>
        
        
        <category>Csharp</category>
        
        <category>Python</category>
        
        <category>Javascript</category>
        
      </item>
    
      <item>
        <title>Transparent Effects</title>
        <description>&lt;p&gt;In Game Development, we often use two ways to achieve transparent effect, Aplha Test and Alpha Blending.&lt;/p&gt;

&lt;hr /&gt;
&lt;h4 id=&quot;1-z-buffer-depth-buffer&quot;&gt;1. Z-Buffer (Depth Buffer)&lt;/h4&gt;

&lt;p align=&quot;center&quot;&gt;     
&lt;img src=&quot;/static/assets/img/blog/z_buffer.png&quot; width=&quot;50%&quot; /&gt;
&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Z-Buffer is used to solve the problems of visibility. It can decide which parts of the object to render first, and which parts of the objects will render later(can be blocked).&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The basic idea is to determine the distance between the camera and the object based on the value of the z-buffer. For example, when we want to render an fragment, the fragment’s depth value will be compared to the depth in the z-buffer (If the ZTest is On). If its depth value is smaller, it means this object is more far away from the camer. so this frament should not be rendered onto screen (which means it is covered by something); Otherwise, this fragment should replace the depth value which is in the z-buffer.&lt;/p&gt;

&lt;hr /&gt;
&lt;h4 id=&quot;2-alpha-test-vs-alpha-blending&quot;&gt;2. Alpha Test vs Alpha Blending&lt;/h4&gt;

&lt;p align=&quot;center&quot;&gt;     
&lt;img src=&quot;/static/assets/img/blog/alpha.gif&quot; width=&quot;70%&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Alpha Test:&lt;/em&gt;&lt;/strong&gt;: As long as there is one fragment’s alpha value does not meet the conditions, the fragment which corresponding to it will be discarded (into a completely transparent fragment). Otherwise, it will be rendered as an opaque object.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Alpha Blending&lt;/em&gt;&lt;/strong&gt;: Through the Alpha blending, we can get a translucent effect. it will combine the current fragment’s alpha value with the color value which has already been stored in the color buffer, to form a new color, but Alpha Blending needs to Turn Off the ZWrite. Therefore, we need to be careful with the rendering order when we are doing alpha blending.&lt;/p&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;3-create-a-alpha-test-shader-in-unity&quot;&gt;3. Create A Alpha Test Shader In Unity&lt;/h4&gt;

&lt;p align=&quot;center&quot;&gt;     
&lt;img src=&quot;/static/assets/img/blog/alpha_test.png&quot; width=&quot;70%&quot; /&gt;
&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Shader &quot;MyShader/AlphaTest&quot; 
{
    Properties
    {
        _Color(&quot;Color&quot;, Color) = (1,1,1,1)
        _MainTex(&quot;Main Texture&quot;, 2D)= &quot;white&quot;{}
        _Cutoff(&quot;Alpha Cutoff&quot;, Range(0,1)) = 0.5
    }
    SubShader
    {
        // Usually when utilize the alpha test we should have these three tags
        Tags { &quot;Queue&quot; = &quot;AlphaTest&quot; &quot;IgnoreProjector&quot; = &quot;True&quot; &quot;RenderType&quot; = &quot;TransparentCutout&quot; }
        Pass
        {
            Tags{ &quot;LightMode&quot; = &quot;ForwardBase&quot; }

            CGPROGRAM
            #pragma vertex vert
            #pragma fragment frag
            #include &quot;Lighting.cginc&quot;

            fixed4 _Color;
            sampler2D _MainTex;
            float4 _MainTex_ST;
            fixed _Cutoff;

            struct a2v
            {
                float4 vertex : POSITION;
                float3 normal : NORMAL;
                float4 texcoord : TEXCOORD0;
            };

            struct v2f
            {
                float4 pos : SV_POSITION;
                float3 worldNormal : TEXCOORD0;
                float3 worldVertex : TEXCOORD1;
                float2 uv : TEXCOORD2;
            };

            v2f vert(a2v v)
            {
                v2f f;
                f.pos = mul(UNITY_MATRIX_MVP, v.vertex);
                f.worldNormal = mul(_Object2World, v.normal);
                f.worldVertex = mul(v.vertex, _World2Object);
                f.uv = v.texcoord.xy*_MainTex_ST.xy+_MainTex_ST.zw;
                return f;
            }

            fixed4 frag(v2f f): SV_Target
            {
                fixed3 worldNormal = normalize(f.worldNormal);
                fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(f.worldVertex));
                fixed4 texColor = tex2D(_MainTex, f.uv);

                // Alpha Test
                if((texColor.a - _Cutoff) &amp;lt; 0.0){ discard; }
                // or use clip function
                //clip(texColor.a - _Cutoff);

                fixed3 albedo = texColor.rgb * _Color.rgb;
                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;
                fixed3 diffuse = _LightColor0.rgb * albedo * saturate(dot(worldNormal,worldLightDir));
                fixed3 c = ambient + diffuse;
                return fixed4(c, 1.0);

            }

            ENDCG
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;4-create-a-alpha-blending-shader-in-unity&quot;&gt;4. Create A Alpha Blending Shader In Unity&lt;/h4&gt;

&lt;p align=&quot;center&quot;&gt;     
&lt;img src=&quot;/static/assets/img/blog/Alpha Blending.png&quot; width=&quot;70%&quot; /&gt;
&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Shader &quot;MyShader/AlphaBlending&quot; 
{
    Properties
    {
        _Color(&quot;Main Tint&quot;, Color) =(1,1,1,1)
        _MainTex(&quot;Main Texture&quot;, 2D) = &quot;white&quot;{}
        _AlphaScale (&quot;Alpha Scale&quot;, Range(0, 1)) = 1
    }

    SubShader
    {
        Tags{ &quot;Queue&quot; = &quot;Transparent&quot; &quot;IgnoreProjector&quot; = &quot;True&quot; &quot;RenderType&quot; = &quot;Transparent&quot; }


        // The first Pass only for store the model's depth info into the z-buffer,
        // to eliminate the fragment which covered by itself in the model
        Pass
        {
            ZWrite On 
            // ColorMask use for mask Color in the model.
            // ColorMask RGB: Mask RGB Color
            // ColorMask A: Mask Alpha Channel
            // ColorMask 0: Mask all color, but since ZWrite is On, it will only pass the z-buffer
            ColorMask 0 
        }

        Pass
        {
            Tags{ &quot;LightMode&quot; = &quot;ForwardBase&quot; }
            ZWrite Off // not passing  z-buffer

            // The semantic for blending mode
            // Blend Off : Close Blending

            // Blend SrcFactor DstFactor: Open Blending, and Set Blending factor.
            // Color in the Color Buffer = The object's fragment color * SrcFactor + The color which is already in color buffer * DstFactor

            // Blend SrcFactor DstFactor, SrcFactorA DstFactorA: Same as above but using different factor for blending alpha channel

            Blend SrcAlpha OneMinusSrcAlpha


            CGPROGRAM
            #pragma vertex vert
            #pragma fragment frag
            #include &quot;Lighting.cginc&quot;

            fixed4 _Color;
            sampler2D _MainTex;
            float4 _MainTex_ST;
            fixed _AlphaScale;

            struct a2v
            {
                float4 vertex : POSITION;
                float3 normal : NORMAL;
                float4 texcoord : TEXCOORD0;
            };

            struct v2f
            {
                float4 pos : SV_POSITION;
                float3 worldNormal : TEXCOORD0;
                float3 worldVertex : TEXCOORD1;
                float2 uv : TEXCOORD2;
            };

            v2f vert(a2v v)
            {
                v2f f;
                f.pos = UnityObjectToClipPos(v.vertex);
                f.worldNormal = mul(unity_ObjectToWorld, v.normal);
                f.worldVertex = mul(v.vertex, unity_WorldToObject);
                f.uv = v.texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw;
                return f;
            }

            fixed4 frag(v2f f): SV_Target
            {
                fixed3 worldNormal = normalize(f.worldNormal);
                fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(f.worldVertex));
                fixed4 texColor = tex2D(_MainTex,f.uv);
                fixed3 albedo = texColor.rgb * _Color.rgb;
                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;
                fixed3 diffuse = _LightColor0.rgb * albedo *saturate(dot(worldNormal,worldLightDir));
                fixed3 c = diffuse + ambient;
                return fixed4(c,texColor.a * _AlphaScale);
            }
            ENDCG
        }
    } 
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;

&lt;h4 id=&quot;5-shaderlab-blending-command&quot;&gt;5. ShaderLab Blending Command&lt;/h4&gt;

&lt;hr /&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Command&lt;/td&gt;
      &lt;td&gt;         &lt;/td&gt;
      &lt;td&gt;Description&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Blend SrcFactor DstFactor&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;Open Blending, and Set Blending factor.Color in the Color Buffer = The object’s fragment color * SrcFactor + The color which is already in color buffer * DstFactor&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Blend SrcFactor DstFactor, SrcFactorA DstFactorA&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;Same function as above, butbut using different factor for blending alpha channe&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;hr /&gt;

&lt;blockquote style=&quot;color: red&quot;&gt;
  &lt;p&gt;So, What are these factors?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Parameters&lt;/td&gt;
      &lt;td&gt;       &lt;/td&gt;
      &lt;td&gt;Description&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;One&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;Factor is 1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Zero&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;Factor is 0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;SrcColor&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;Factor is the source color value&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;SrcAlpha&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;Factor is the source alpha value&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;DstColor&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;Factor is the target color value&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;DstAlpha&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;Factor is the target alpha value&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;OneMinusSrcColor&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;Factor is 1 - source color value&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;OneMinusSrcAlpha&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;Factor is 1 - source alpha value&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;OneMinusDstColor&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;Factor is 1 - target color value&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;OneMinusDstAlpha&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;Factor is 1 - target alpha value&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;hr /&gt;

&lt;blockquote style=&quot;color: red&quot;&gt;
  &lt;p&gt;We also can sue ShaderLab’s BlendOp Command to perform various blending operations&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Operation&lt;/td&gt;
      &lt;td&gt;         &lt;/td&gt;
      &lt;td&gt;Description&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Add&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;O = SrcFactor * SourceColor + DstFactor * TargetColor&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Sub&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;O = SrcFactor * SourceColor - DstFactor * TargetColor&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;RevSub&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;O = DstFactor * TargetColor - SrcFactor * SourceColor&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Min&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;O = (min(S.r, D.r), min(S.g, D.g), min(S.b, D.b), min(S.a, D.a))&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Max&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;O = (max(S.r, D.r), max(S.g, D.g), max(S.b, D.b), max(S.a, D.a))&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;hr /&gt;

&lt;blockquote style=&quot;color: red&quot;&gt;
  &lt;p&gt;The Common Blending Type:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p align=&quot;center&quot;&gt;     
&lt;img src=&quot;/static/assets/img/blog/Blending Mode.png&quot; width=&quot;70%&quot; /&gt;
&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Blend SrcAlpha OneMinusSrcAlpha  // Normal

Blend OneMinusDstColor One  // Soft Additive

Blend DstColor Zero  // Multiply

Blend DstColor SrcColor  // 2x Multiply

BlendOp Min    // Darken
Blend One One

BlendOp Max   // Lighten
Blend One One

Blend OneMinusDstColor One // Screen
Blend One OneMinusSrcColor // Same as above

Blend One One // Linear Dodge
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;End –Cheng Gu&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

</description>
        <pubDate>Tue, 10 Jul 2018 00:00:00 -0700</pubDate>
        <link>http://localhost:4000/cg/unity/2018/07/10/TransparentEffect.html</link>
        <guid isPermaLink="true">http://localhost:4000/cg/unity/2018/07/10/TransparentEffect.html</guid>
        
        <category>Unity</category>
        
        <category>Shader</category>
        
        <category>Math</category>
        
        <category>CG</category>
        
        
        <category>Cg</category>
        
        <category>Unity</category>
        
      </item>
    
      <item>
        <title>Ramp &amp; Mask Texture</title>
        <description>&lt;p&gt;Ramp Texture allows us to control the diffuse light of an object. Mask Texture can protect some part of the texture not be influence.&lt;/p&gt;

&lt;hr /&gt;
&lt;h4 id=&quot;1-ramp-texture&quot;&gt;1. Ramp Texture&lt;/h4&gt;

&lt;p align=&quot;center&quot;&gt;     
&lt;img src=&quot;/static/assets/img/blog/ramp.png&quot; width=&quot;70%&quot; /&gt;
&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Shader &quot;MyShader/RampMap&quot;
{
    Properties {
        _Color (&quot;Color Tint&quot;, Color) = (1, 1, 1, 1)
        _RampTex (&quot;Ramp Tex&quot;, 2D) = &quot;white&quot; {}
        _Specular (&quot;Specular&quot;, Color) = (1, 1, 1, 1)
        _Gloss (&quot;Gloss&quot;, Range(8.0, 256)) = 20
    }
    SubShader {
        Pass { 
            Tags { &quot;LightMode&quot;=&quot;ForwardBase&quot; }
        
            CGPROGRAM
            
            #pragma vertex vert
            #pragma fragment frag

            #include &quot;Lighting.cginc&quot;
            
            fixed4 _Color;
            sampler2D _RampTex;
            float4 _RampTex_ST;
            fixed4 _Specular;
            float _Gloss;
            
            struct a2v {
                float4 vertex : POSITION;
                float3 normal : NORMAL;
                float4 texcoord : TEXCOORD0;
            };
            
            struct v2f {
                float4 pos : SV_POSITION;
                float3 worldNormal : TEXCOORD0;
                float3 worldPos : TEXCOORD1;
                float2 uv : TEXCOORD2;
            };
            
            v2f vert(a2v v) {
                v2f o;
                o.pos = UnityObjectToClipPos(v.vertex);
                
                o.worldNormal = UnityObjectToWorldNormal(v.normal);
                
                o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
                
                o.uv = TRANSFORM_TEX(v.texcoord, _RampTex);
                
                return o;
            }
            
            fixed4 frag(v2f i) : SV_Target {
                fixed3 worldNormal = normalize(i.worldNormal);
                fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos));
                
                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;
                
                // Use the texture to sample the diffuse color
                fixed halfLambert  = 0.5 * dot(worldNormal, worldLightDir) + 0.5;
                fixed3 diffuseColor = tex2D(_RampTex, fixed2(halfLambert, halfLambert)).rgb * _Color.rgb;
                
                fixed3 diffuse = _LightColor0.rgb * diffuseColor;
                
                fixed3 viewDir = normalize(UnityWorldSpaceViewDir(i.worldPos));
                fixed3 halfDir = normalize(worldLightDir + viewDir);
                fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(max(0, dot(worldNormal, halfDir)), _Gloss);
                
                return fixed4(ambient + diffuse + specular, 1.0);
            }
            ENDCG
        }
    } 
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;
&lt;h4 id=&quot;2-mask-texture&quot;&gt;2. Mask Texture&lt;/h4&gt;

&lt;p align=&quot;center&quot;&gt;     
&lt;img src=&quot;/static/assets/img/blog/mask.png&quot; width=&quot;70%&quot; /&gt;
&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Shader &quot;MyShader/7. MaskMap&quot;
{
    Properties
    {
        _Color(&quot;Color&quot;, Color) = (1,1,1,1)
        _MainTex(&quot;MainTex&quot;,2D) = &quot;white&quot;{}
        _BumpMap(&quot;Normal Map&quot;,2D) = &quot;bump&quot;{}
        _BumpScale(&quot;Bump Scale&quot;, Float) = 1.0
        _SpecularMask (&quot;Specular Mask&quot;, 2D) = &quot;white&quot;{}
        _SpecularScale(&quot;Specular Scale&quot;, Float) = 1
        _Specular(&quot;Specular&quot;, Color) =(1,1,1,1)
        _Gloss(&quot;Gloss&quot;,Range(5,100)) = 5
    }

    SubShader
    {
        Pass
        {
            Tags{&quot;LightMode&quot; = &quot;ForwardBase&quot;}
            CGPROGRAM
            #pragma vertex vert
            #pragma fragment frag
            #include &quot;Lighting.cginc&quot;

            fixed4 _Color;
            sampler2D _MainTex;
            float4 _MainTex_ST;
            sampler2D _BumpMap;
            float _BumpScale;
            sampler2D _SpecularMask;
            float _SpecularScale;
            fixed4 _Specular;
            float _Gloss;

            struct a2v
            {
                float4 vertex : POSITION;
                float3 normal : NORMAL;
                float4 tangent : TANGENT;
                float4 texcoord : TEXCOORD0;
            };

            struct v2f
            {
                float4 pos : SV_POSITION;
                float2 uv : TEXCOORD0;
                float3 lightDir : TEXCOORD1;
                float3 viewDir : TEXCOORD2;
            };

            v2f vert(a2v v)
            {
                v2f f;
                f.pos = UnityObjectToClipPos(v.vertex);
                f.uv = v.texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw;

                TANGENT_SPACE_ROTATION;

                f.lightDir = mul(rotation, ObjSpaceLightDir(v.vertex)).xyz;
                f.viewDir = mul(rotation, ObjSpaceViewDir(v.vertex)).xyz;

                return f;
            }

            fixed4 frag(v2f f) : SV_Target
            {
                fixed3 tangentLightDir = normalize(f.lightDir);
                fixed3 tangentViewDir = normalize(f.viewDir);

                fixed3 tangentNormalDir = UnpackNormal(tex2D(_BumpMap,f.uv));
                tangentNormalDir.xy *= _BumpScale;
                tangentNormalDir.z = sqrt(1 - saturate(dot(tangentNormalDir.xy, tangentNormalDir.xy)));

                fixed3 albedo = tex2D(_MainTex, f.uv).rgb * _Color.rgb;
                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.rgb * albedo;
                fixed3 diffuse = _LightColor0.rgb * albedo * saturate(dot(tangentLightDir,tangentNormalDir));

                fixed3 halfDir = normalize(tangentViewDir + tangentLightDir);

                fixed specularMask = tex2D(_SpecularMask, f.uv).r *_SpecularScale;
                fixed3 specular = _LightColor0.rgb * _Specular.rgb * specularMask * pow(saturate(dot(halfDir,tangentNormalDir)),_Gloss);

                fixed3 c = ambient + diffuse + specular;

                return fixed4 (c,1);
            }
            ENDCG
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;End –Cheng Gu&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

</description>
        <pubDate>Fri, 29 Jun 2018 00:00:00 -0700</pubDate>
        <link>http://localhost:4000/cg/unity/2018/06/29/Ramp-And-Mask.html</link>
        <guid isPermaLink="true">http://localhost:4000/cg/unity/2018/06/29/Ramp-And-Mask.html</guid>
        
        <category>Unity</category>
        
        <category>Shader</category>
        
        <category>Math</category>
        
        <category>CG</category>
        
        
        <category>Cg</category>
        
        <category>Unity</category>
        
      </item>
    
      <item>
        <title>Bump Mapping</title>
        <description>&lt;p&gt;Bump mapping is used for giving models more details with cheap costs by modifying the normal of the model .&lt;/p&gt;

&lt;p&gt;This method doesn’t change the models detail level, but give us a visual effect that the model has more details after bump mapping.&lt;/p&gt;

&lt;hr /&gt;
&lt;h4 id=&quot;1-two-kinds-of--bump-maping&quot;&gt;1. Two Kinds of  Bump Maping&lt;/h4&gt;

&lt;p&gt;There are two common ways to do the bump mapping, which are Height Mapping, and Normal Mapping.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;     
&lt;img src=&quot;/static/assets/img/blog/hm_nm.png&quot; width=&quot;70%&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;Use a height map to simulate the surface displacement. If the color are darker, the surface are lower; if the color are lighter, the surface are higher. The advantage of this using height map is make the height of the surface more obviouse to see. But it is also more expensive performance.&lt;/p&gt;

&lt;p&gt;Normally we will use normal map to modify the light. In Normal map, it represents the direction of the normal. The range of normal’s component range is [-1,1], but the pixel’s component range is [0,1].So that we need to do a mapping&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Pixel = (Normal + 1) / 2&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;This will require us to use a inverse function to get the original normal direction after mapping the pixel in the Shader&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Normal = Pixel x 2 - 1&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p align=&quot;center&quot;&gt;     
&lt;img src=&quot;/static/assets/img/blog/tangent space and model space.png&quot; width=&quot;70%&quot; /&gt;
&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;The above image respectively gives us the normal map in the model space and tangent space.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;
&lt;h4 id=&quot;2-normal-mapping-in-tangent-space&quot;&gt;2. Normal Mapping in Tangent Space&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;The advantage in the tangent space to calculate normal mapping is more efficient don’t need too many conversion.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Shader &quot;MyShader/NormalMapInTangentSpace&quot;
{
 Properties
 {
    _Color(&quot;Color&quot;,Color) = (1,1,1,1)
    _MainTex (&quot;Texture&quot;, 2D) = &quot;white&quot; {}
    _BumpMap(&quot;Normal Map&quot;,2D) = &quot;bump&quot; {}
    _BumpScale(&quot;Bump Scale&quot;,Float) = 1.0
    _Specular(&quot;Specular&quot;,Color) = (1,1,1,1)
    _Gloss(&quot;Gloss&quot;,Range(5,100)) = 5
 }
 SubShader
 {
    Pass
    {
        Tags{&quot;LightMode&quot; = &quot;ForwardBase&quot;}
        CGPROGRAM 
        #pragma vertex vert
        #pragma fragment frag
        #include &quot;Lighting.cginc&quot;

        fixed4 _Color;
        sampler2D _MainTex;
        float4 _MainTex_ST;
        sampler2D _BumpMap;
        float4 _BumpMap_ST;
        float _BumpScale;
        fixed4 _Specular;
        float _Gloss;

        struct a2v
        {
            float4 vertex : POSITION;
            float3 normal : NORMAL;

            // We use TANGENT semantic to describe a float4 type variable tangent,
            // to tell CG give the vertices' tangent direction to the variable tangent.
            // compared with normal, tangent is a float4 variable,
            // because we need tangent.w to determine the binormal's direction
            float4 tangent : TANGENT;
            float4 texcoord : TEXCOORD0;
        };

        struct v2f
        {
            float4 pos : SV_POSITION;
            float4 uv : TEXCOORD0;
            float3 lightDir : TEXCOORD1;
            float3 viewDir : TEXCOORD2;
        };

        v2f vert(a2v v)
        {
            v2f o;
            o.pos = UnityObjectToClipPos(v.vertex);
                
            o.uv.xy = v.texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw;
            o.uv.zw = v.texcoord.xy * _BumpMap_ST.xy + _BumpMap_ST.zw;
               

            // Compute the binormal
            // float3 binormal = cross( normalize(v.normal), normalize(v.tangent.xyz) ) * v.tangent.w;
            // Construct a matrix which transform vectors from object space to tangent space
            // float3x3 rotation = float3x3(v.tangent.xyz, binormal, v.normal);
            // Or just use the built-in macro
            TANGENT_SPACE_ROTATION;

            // Transform the light direction from object space to tangent space
            o.lightDir = mul(rotation, normalize(ObjSpaceLightDir(v.vertex))).xyz;
            // Transform the view direction from object space to tangent space
            o.viewDir = mul(rotation, normalize(ObjSpaceViewDir(v.vertex))).xyz;
                
            return o;
        }

        fixed4 frag(v2f f) : SV_Target
        {
            fixed3 tangentLightDir = normalize(f.lightDir);
            fixed3 tangentViewDir = normalize(f.viewDir);

            fixed4 packedNormal = tex2D(_BumpMap,f.uv.zw);

            // if the texture is not marked as &quot;Normal Map&quot;
            //fixed3 tangentNormal;
            //tangentNormal.xy =(packedNormal.xy * 2 - 1) * _BumpScale;
            //else
            fixed3 tangentNormal = UnpackNormal(packedNormal);
            tangentNormal.xy *= _BumpScale;

            tangentNormal.z = sqrt(1.0 - saturate(dot(tangentNormal.xy, tangentNormal.xy)));

            fixed3 albedo = tex2D(_MainTex, f.uv.xy).rgb * _Color.rgb;
            fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;
            fixed3 diffuse = _LightColor0.rgb * albedo * saturate(dot(tangentNormal,tangentLightDir));
            fixed3 halfDir = normalize(tangentLightDir + tangentViewDir);
            fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(saturate(dot(halfDir, tangentNormal)),_Gloss);
            fixed3 c = ambient + diffuse + specular;

            return fixed4(c,1);
        }
        ENDCG
    }
 }
  FallBack &quot;Specular&quot;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;
&lt;h4 id=&quot;3-normal-mapping-in-world-space&quot;&gt;3. Normal Mapping in World Space&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;However, from a general point of view, normal mapping in world space is better than in tangent space. For example if we need to use Cubemap to mapping the environment we have to&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Shader &quot;MyShader/NormalMapInWorldSpace&quot;
{
    Properties 
    {
        _Color (&quot;Color Tint&quot;, Color) = (1, 1, 1, 1)
        _MainTex (&quot;Main Tex&quot;, 2D) = &quot;white&quot; {}
        _BumpMap (&quot;Normal Map&quot;, 2D) = &quot;bump&quot; {}
        _BumpScale (&quot;Bump Scale&quot;, Float) = 1.0
        _Specular (&quot;Specular&quot;, Color) = (1, 1, 1, 1)
        _Gloss (&quot;Gloss&quot;, Range(8.0, 256)) = 20
    }
    SubShader 
    {
        Pass 
        { 
            Tags { &quot;LightMode&quot;=&quot;ForwardBase&quot; }
        
            CGPROGRAM
            
            #pragma vertex vert
            #pragma fragment frag
            
            #include &quot;Lighting.cginc&quot;
            
            fixed4 _Color;
            sampler2D _MainTex;
            float4 _MainTex_ST;
            sampler2D _BumpMap;
            float4 _BumpMap_ST;
            float _BumpScale;
            fixed4 _Specular;
            float _Gloss;
            
            struct a2v 
            {
                float4 vertex : POSITION;
                float3 normal : NORMAL;
                float4 tangent : TANGENT;
                float4 texcoord : TEXCOORD0;
            };
            
            struct v2f 
            {
                float4 pos : SV_POSITION;
                float4 uv : TEXCOORD0;
                float4 TtoW0 : TEXCOORD1;  
                float4 TtoW1 : TEXCOORD2;  
                float4 TtoW2 : TEXCOORD3; 
            };
            
            v2f vert(a2v v) 
            {
                v2f o;
                o.pos = mul(UNITY_MATRIX_MVP, v.vertex);
                
                o.uv.xy = v.texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw;
                o.uv.zw = v.texcoord.xy * _BumpMap_ST.xy + _BumpMap_ST.zw;
                
                float3 worldPos = mul(_Object2World, v.vertex).xyz;  
                fixed3 worldNormal = UnityObjectToWorldNormal(v.normal);  
                fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);  
                fixed3 worldBinormal = cross(worldNormal, worldTangent) * v.tangent.w; 
                
                // Compute the matrix that transform directions from tangent space to world space
                // Put the world position in w component for optimization
                o.TtoW0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
                o.TtoW1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
                o.TtoW2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
                
                return o;
            }
            
            fixed4 frag(v2f i) : SV_Target 
            {
                // Get the position in world space      
                float3 worldPos = float3(i.TtoW0.w, i.TtoW1.w, i.TtoW2.w);
                // Compute the light and view dir in world space
                fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
                fixed3 viewDir = normalize(UnityWorldSpaceViewDir(worldPos));
                
                // Get the normal in tangent space
                fixed3 bump = UnpackNormal(tex2D(_BumpMap, i.uv.zw));
                bump.xy *= _BumpScale;
                bump.z = sqrt(1.0 - saturate(dot(bump.xy, bump.xy)));
                // Transform the narmal from tangent space to world space
                bump = normalize(half3(dot(i.TtoW0.xyz, bump), dot(i.TtoW1.xyz, bump), dot(i.TtoW2.xyz, bump)));
                
                fixed3 albedo = tex2D(_MainTex, i.uv).rgb * _Color.rgb;
                
                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;
                
                fixed3 diffuse = _LightColor0.rgb * albedo * max(0, dot(bump, lightDir));

                fixed3 halfDir = normalize(lightDir + viewDir);
                fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(max(0, dot(bump, halfDir)), _Gloss);
                
                return fixed4(ambient + diffuse + specular, 1.0);
            }
            ENDCG
        }
    } 
    FallBack &quot;Specular&quot;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;End –Cheng Gu&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

</description>
        <pubDate>Sat, 23 Jun 2018 00:00:00 -0700</pubDate>
        <link>http://localhost:4000/cg/unity/2018/06/23/Bump-Mapping.html</link>
        <guid isPermaLink="true">http://localhost:4000/cg/unity/2018/06/23/Bump-Mapping.html</guid>
        
        <category>Unity</category>
        
        <category>Shader</category>
        
        <category>Math</category>
        
        <category>CG</category>
        
        
        <category>Cg</category>
        
        <category>Unity</category>
        
      </item>
    
      <item>
        <title>Texture Mapping</title>
        <description>&lt;p&gt;The basic idea of “texture mapping” is to put a flat image onto the surface of a three-dimensional shape.&lt;/p&gt;

&lt;hr /&gt;
&lt;h4 id=&quot;1-create-a-single-texture-shader&quot;&gt;1. Create a Single Texture Shader&lt;/h4&gt;

&lt;p align=&quot;center&quot;&gt;   
&lt;img src=&quot;/static/assets/img/blog/st.png&quot; width=&quot;70%&quot; /&gt;
&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    Shader &quot;MyShader/SingleTexture&quot;
{
    Properties
    {
        _MainTex(&quot;Texture&quot;,2D) =&quot;white&quot;{}
    }
    SubShader
    {
        Pass
        {
            Tags{&quot;LightMode&quot; = &quot;ForwardBase&quot;}
            CGPROGRAM
            #pragma vertex vert
            #pragma fragment frag

            // In order to use some built-in variables, 
            // we need to use &quot;Lighting.cginc&quot; Library which is builtin unity
            #include &quot;Lighting.cginc&quot;

            sampler2D _MainTex;

            // Compared with other properties, we not only need to declare a sampler2D type variable,
            // but also we should declare a float4 type variable _MainTex_ST. 
            // Names are not random. We MUST follow &quot;Texture Name&quot;_ST. 
            // S represents scale, T represents transformation.
            float4 _MainTex_ST;

            struct a2v
            {
                float4 vertex : POSITION;
                float4 texcoord : TEXCOORD0;
            };

            struct v2f
            {
                float4 pos : SV_POSITION;
                float2 uv : TEXCOORD0;
            };

            v2f vert(a2v v)
            {
                v2f f;
                f.pos = mul(UNITY_MATRIX_MVP, v.vertex);


                f.uv = v.texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw;
                // or just call below function which builtin cg
                //f.uv = TRANSFORM_TEX(v.texcoord, _MainTex);
                return f;
            }

            fixed4 frag(v2f f) : SV_Target
            {
                fixed3 c = tex2D(_MainTex, f.uv).rgb;
                return fixed4(c,1); 
            } 
            ENDCG
        }
    }
    FallBack &quot;Diffuse&quot;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;
&lt;h4 id=&quot;2-combine-texture-with-lighting-model&quot;&gt;2. Combine Texture with Lighting Model&lt;/h4&gt;

&lt;p align=&quot;center&quot;&gt;   
&lt;img src=&quot;/static/assets/img/blog/texinLightmodel.png&quot; width=&quot;70%&quot; /&gt;
&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Shader &quot;MyShader/TextureInLightModel&quot;
{
    Properties
    {
        _Color(&quot;Color&quot;, Color) = (1,1,1,1)
        _MainTex(&quot;Texture&quot;, 2D) =&quot;white&quot;{}
        _Specular(&quot;Specular&quot;, Color) = (1,1,1,1)
        _Gloss(&quot;Gloss&quot;, Range(5,100)) = 5
    } 

    SubShader
    {
        Pass
        {
            Tags{&quot;LightMode&quot; = &quot;ForwardBase&quot;}
            CGPROGRAM
            #pragma vertex vert
            #pragma fragment frag

            #include &quot;Lighting.cginc&quot;

            sampler2D _MainTex;
            float4 _MainTex_ST;

            fixed4 _Color;
            fixed4 _Specular;
            float _Gloss;

            struct a2v
            {
                float4 vertex : POSITION;
                float3 normal : NORMAL;
                float4 texcoord : TEXCOORD0;
            };

            struct v2f
            {
                float4 pos : SV_POSITION;
                float4 worldVertex : TEXCOORD0;
                float3 worldNormal : TEXCOORD1;
                float2 uv : TEXCOORD2;
            };

            v2f vert(a2v v)
            {
                v2f f;
                f.pos = UnityObjectToClipPos(v.vertex);
                f.worldNormal = mul(_Object2World, v.normal);
                f.worldVertex = mul(_Object2World, v.vertex);
                f.uv = v.texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw;
                // or just call below function which builtin cg
                //f.uv = TRANSFORM_TEX(v.texcoord, _MainTex);
                return f;
            }

            fixed4 frag(v2f f) : SV_Target
            {
                fixed3 worldNormalDir = normalize(f.worldNormal);
                fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(f.worldVertex));
                fixed3 albedo = tex2D(_MainTex, f.uv).rgb * _Color.rgb;
                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;
                fixed3 diffuse = _LightColor0.rgb * albedo * saturate(dot(worldNormalDir, worldLightDir));

                fixed3 viewDir = normalize(UnityWorldSpaceViewDir(f.worldVertex));
                fixed3 halfDir = normalize(viewDir + worldLightDir);
                fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(saturate(dot(halfDir,worldNormalDir)),_Gloss);

                fixed3 c = ambient + diffuse + specular;

                return fixed4(c,1); 
            } 
            ENDCG
        }
    }
    FallBack &quot;Diffuse&quot;
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;End –Cheng Gu&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

</description>
        <pubDate>Wed, 20 Jun 2018 00:00:00 -0700</pubDate>
        <link>http://localhost:4000/cg/unity/2018/06/20/Single-Texture.html</link>
        <guid isPermaLink="true">http://localhost:4000/cg/unity/2018/06/20/Single-Texture.html</guid>
        
        <category>Unity</category>
        
        <category>Shader</category>
        
        <category>Math</category>
        
        <category>CG</category>
        
        
        <category>Cg</category>
        
        <category>Unity</category>
        
      </item>
    
      <item>
        <title>Tangent Space</title>
        <description>&lt;p&gt;Tangent Space is one of the important coordinate in CG. The most important usage of Tangent Space is &lt;strong&gt;&lt;em&gt;normal mapping&lt;/em&gt;&lt;/strong&gt;.&lt;/p&gt;

&lt;hr /&gt;
&lt;h4 id=&quot;1-what-is-tangent-space&quot;&gt;1. What is Tangent Space&lt;/h4&gt;

&lt;p align=&quot;center&quot;&gt;     
&lt;img src=&quot;/static/assets/img/blog/tangent space.png&quot; width=&quot;50%&quot; /&gt;
&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Intuitively, the texture coordinates in a model’s vertices are defined in the tangent space.Ordinary, 2-dimensional texture coordinates include &lt;strong&gt;&lt;em&gt;U&lt;/em&gt;&lt;/strong&gt; and &lt;strong&gt;&lt;em&gt;V&lt;/em&gt;&lt;/strong&gt;. The direction of U grows is the tangent axis; the direction of V grows is the binormal(also called bitangent) axis. The coordinate system which composed of the &lt;strong&gt;&lt;em&gt;Tangent&lt;/em&gt;&lt;/strong&gt;, &lt;strong&gt;&lt;em&gt;Binormal&lt;/em&gt;&lt;/strong&gt;, and &lt;strong&gt;&lt;em&gt;Normal&lt;/em&gt;&lt;/strong&gt; is the &lt;strong&gt;&lt;em&gt;Tangent Space&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;
&lt;h4 id=&quot;2-calculating-tangent-space&quot;&gt;2. Calculating Tangent Space&lt;/h4&gt;

&lt;p align=&quot;center&quot;&gt;     
&lt;img src=&quot;/static/assets/img/blog/tangent space2.png&quot; width=&quot;50%&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;This picture showed a trangle and its tangent space. and it have three vertices &lt;strong&gt;&lt;em&gt;P0, P1, P2. E0 = P1 - P0, E1 = P2 - P0&lt;/em&gt;&lt;/strong&gt;, so the corresponding texture coordinate difference is: &lt;strong&gt;&lt;em&gt;(T1, B1) = (U1-U0, V1-V0), (T2, B2) = (U2-U0,V2-V0)&lt;/em&gt;&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;From here we can get:&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;E0 = T1 x T + B1 x B&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;E1 = T2 x T + B2 x B&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;So that we can write it as a Matrix:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/assets/img/blog/tangent space_matrix.png&quot; width=&quot;20%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Then, break them down into components:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/assets/img/blog/tangent space_matrix2.png&quot; width=&quot;30%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Two Sides multiply by the inverse of TB Matrix:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/assets/img/blog/tangent space_matrix4.png&quot; width=&quot;30%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Based on Matrix formula, when there is a matrix &lt;img src=&quot;/static/assets/img/blog/tangent space_matrix5.png&quot; width=&quot;10%&quot; /&gt;, we can get its Inverse Matrix:
&lt;img src=&quot;/static/assets/img/blog/tangent space_matrix6.png&quot; width=&quot;20%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Therefore, the above formular can be further expressed as:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/assets/img/blog/tangent space_matrix7.png&quot; width=&quot;40%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;At this point, the data on the right side of the equal sign are all known, so the matrix on the left can be easy to calculate, and obtain the T and B Axis in the tangent space. The N-Axis, which is the normal to the trangular surface, it can be easily calculate by using Cross Product of Tangent Axis, and Binormal Axis.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;There is one thing important in this calculation: the result of T vector and B vector were not normalized, which means the length is not equal. Also for the case of texture coordinate transformation, the T and B axis are not perpendicular to each other.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;However, in most cases, we only need to normalize the T,B,N vectors without worrying about their coorresponding length. For example, in normal mapping, we use the TBN coordinated system only for the purpose of converting the normals from tangent space to world space without any relation to the texture coordinates. Therefore, here I use three of the TBN coordinates are all ready to go.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;End –Cheng Gu&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

</description>
        <pubDate>Sun, 10 Jun 2018 07:15:05 -0700</pubDate>
        <link>http://localhost:4000/cg/math/2018/06/10/Tangent-Space.html</link>
        <guid isPermaLink="true">http://localhost:4000/cg/math/2018/06/10/Tangent-Space.html</guid>
        
        <category>Unity</category>
        
        <category>Shader</category>
        
        <category>Math</category>
        
        <category>CG</category>
        
        
        <category>Cg</category>
        
        <category>Math</category>
        
      </item>
    
      <item>
        <title>Common Lighting Models</title>
        <description>&lt;p&gt;In this post, I focus on reviewing the Lighting Models I learned these days which are &lt;strong&gt;&lt;em&gt;Diffuse(Lambert)&lt;/em&gt;&lt;/strong&gt;, &lt;strong&gt;&lt;em&gt;Half-Lambert&lt;/em&gt;&lt;/strong&gt;, &lt;strong&gt;&lt;em&gt;Specular&lt;/em&gt;&lt;/strong&gt;, and &lt;strong&gt;&lt;em&gt;Blinn-Phong&lt;/em&gt;&lt;/strong&gt;.&lt;/p&gt;

&lt;hr /&gt;
&lt;h4 id=&quot;1-diffuselambert&quot;&gt;1. Diffuse(Lambert)&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/static/assets/img/blog/lambert.png&quot; width=&quot;50%&quot; /&gt;
&lt;img src=&quot;/static/assets/img/blog/Lambert rule.png&quot; width=&quot;40%&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;

  &lt;ul&gt;
    &lt;li&gt;M_diff：material color.&lt;/li&gt;
    &lt;li&gt;S_diff：light source color.&lt;/li&gt;
    &lt;li&gt;n · l：the radius of the angle between normal and light direction by using dot product to calculate.&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;(1) &lt;strong&gt;&lt;em&gt;Lambert Per-Vertex-Level (Low Cost, but less accurate)&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Shader &quot;MyShader/Diffuse Vertex-Level&quot; 
{
    Properties 
    {
        _Diffuse (&quot;Diffuse&quot;, Color) = (1, 1, 1, 1)
    }
    SubShader 
    {
        Pass 
        { 
            Tags { &quot;LightMode&quot;=&quot;ForwardBase&quot; }
            
            CGPROGRAM
            
            #pragma vertex vert
            #pragma fragment frag
            
            #include &quot;Lighting.cginc&quot;
            
            fixed4 _Diffuse;
            
            struct a2v 
            {
                float4 vertex : POSITION;
                float3 normal : NORMAL;
            };
            
            struct v2f 
            {
                float4 pos : SV_POSITION;
                fixed3 color : COLOR;
            };
            
            v2f vert(a2v v) 
            {
                v2f o;
                // Transform the vertex from object space to projection space
                o.pos = mul(UNITY_MATRIX_MVP, v.vertex);
                
                // Get ambient term
                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;
                
                // Transform the normal from object space to world space
                fixed3 worldNormal = normalize(mul(v.normal, (float3x3)_World2Object));
                // Get the light direction in world space
                fixed3 worldLight = normalize(_WorldSpaceLightPos0.xyz);
                // Compute diffuse term
                fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * saturate(dot(worldNormal, worldLight));
                
                o.color = ambient + diffuse;
                
                return o;
            }
            
            fixed4 frag(v2f i) : SV_Target
            {
                return fixed4(i.color, 1.0);
            }
            ENDCG
        }
    }
    FallBack &quot;Diffuse&quot;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;(2) &lt;strong&gt;&lt;em&gt;Lambert Per-Pixel-Level (higher Cost, but more accurate)&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Shader &quot;MyShader/Diffuse Pixel-Level&quot; {
    Properties 
    {
        _Diffuse (&quot;Diffuse&quot;, Color) = (1, 1, 1, 1)
    }
    SubShader 
    {
        Pass 
        { 
            Tags { &quot;LightMode&quot;=&quot;ForwardBase&quot; }
            CGPROGRAM
            
            #pragma vertex vert
            #pragma fragment frag
            
            #include &quot;Lighting.cginc&quot;
            
            fixed4 _Diffuse;
            
            struct a2v 
            {
                float4 vertex : POSITION;
                float3 normal : NORMAL;
            };
            
            struct v2f
            {
                float4 pos : SV_POSITION;
                float3 worldNormal : TEXCOORD0;
            };
            
            v2f vert(a2v v) 
            {
                v2f o;
                // Transform the vertex from object space to projection space
                o.pos = mul(UNITY_MATRIX_MVP, v.vertex);

                // Transform the normal from object space to world space
                o.worldNormal = mul(v.normal, (float3x3)_World2Object);

                return o;
            }
            
            fixed4 frag(v2f i) : SV_Target 
            {
                // Get ambient term
                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;
                
                // Get the normal in world space
                fixed3 worldNormal = normalize(i.worldNormal);
                // Get the light direction in world space
                fixed3 worldLightDir = normalize(_WorldSpaceLightPos0.xyz);
                
                // Compute diffuse term
                fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * saturate(dot(worldNormal, worldLightDir)); 
                fixed3 color = ambient + diffuse;
                
                return fixed4(color, 1.0);
            } 
            ENDCG
        }
    } 
    FallBack &quot;Diffuse&quot;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;(3) &lt;strong&gt;&lt;em&gt;Lambert in Unity Surface Shader&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Shader &quot;MyShader/SurfaceShader_Diffuse&quot; 
{
    Properties 
    {
        _Color (&quot;Color&quot;, Color) = (1,1,1,1)
        _MainTex (&quot;Albedo (RGB)&quot;, 2D) = &quot;white&quot; {}
    }
    SubShader 
    {
        Tags { &quot;RenderType&quot;=&quot;Opaque&quot; }

        CGPROGRAM
        #pragma surface surf SimpleLambert
        
        sampler2D _MainTex;
        fixed4 _Color;

        struct Input
        {
            float2 uv_MainTex;
        };
        
        // Custom Lighting Model
        half4 LightingSimpleLambert(SurfaceOutput s, half3 lightDir, half atten)
        {
            // Get the dot product of normal and light
            half NdotL = dot(s.Normal, lightDir);
        
            half3 color = s.Albedo * _LightColor0.rgb * saturate(NdotL) * atten);
            
            return fixed4(color,1);
        }

        void surf (Input IN, inout SurfaceOutput o) 
        {
            fixed4 c = tex2D (_MainTex, IN.uv_MainTex) * _Color;
            o.Albedo = c.rgb;
        }
        ENDCG
    }
    FallBack &quot;Diffuse&quot;
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;
&lt;h4 id=&quot;2-half-lambert&quot;&gt;2. Half Lambert&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/static/assets/img/blog/half_lambert.png&quot; width=&quot;70%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;(2) &lt;strong&gt;&lt;em&gt;HalfLambert in Unity vertex/fragment Shader&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Shader &quot;MyShader/Half Lambert-Pixel-Level&quot; 
{
    Properties 
    {
        _Diffuse (&quot;Diffuse&quot;, Color) = (1, 1, 1, 1)
    }
    SubShader 
    {
        Pass 
        { 
            Tags { &quot;LightMode&quot;=&quot;ForwardBase&quot; }
            
            CGPROGRAM
            
            #pragma vertex vert
            #pragma fragment frag
            
            #include &quot;Lighting.cginc&quot;
            
            fixed4 _Diffuse;
            
            struct a2v 
            {
                float4 vertex : POSITION;
                float3 normal : NORMAL;
            };
            
            struct v2f 
            {
                float4 pos : SV_POSITION;
                float3 worldNormal : TEXCOORD0;
            };
            
            v2f vert(a2v v) 
            {
                v2f o;
                // Transform the vertex from object space to projection space
                o.pos = mul(UNITY_MATRIX_MVP, v.vertex);
                
                // Transform the normal from object space to world space
                o.worldNormal = mul(v.normal, (float3x3)_World2Object);
                
                return o;
            }
            
            fixed4 frag(v2f i) : SV_Target 
            {
                // Get ambient term
                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;
                
                // Get the normal in world space
                fixed3 worldNormal = normalize(i.worldNormal);
                // Get the light direction in world space
                fixed3 worldLightDir = normalize(_WorldSpaceLightPos0.xyz);
                
                // Compute diffuse term
                fixed halfLambert = dot(worldNormal, worldLightDir) * 0.5 + 0.5;
                fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * halfLambert;
                
                fixed3 color = ambient + diffuse;
                
                return fixed4(color, 1.0);
            }
            ENDCG
        }
    } 
    FallBack &quot;Diffuse&quot;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;(2) &lt;strong&gt;&lt;em&gt;HalfLambert in Unity Surface Shader&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Shader &quot;MyShader/SurfaceShader_HalfLambert&quot; 
{
    Properties 
    {
        _Color (&quot;Color&quot;, Color) = (1,1,1,1)
        _MainTex (&quot;Albedo (RGB)&quot;, 2D) = &quot;white&quot; {}
    }
    SubShader
    {
        Tags { &quot;RenderType&quot;=&quot;Opaque&quot; }
        CGPROGRAM
        #pragma surface surf HalfLambert
        
        sampler2D _MainTex;
        fixed4 _Color;

        struct Input
        {
            float2 uv_MainTex;
        };
        
        // Custom Lighting Model
        half4 LightingHalfLambert(SurfaceOutput s, half3 lightDir)
        {
            // Get the dot product of normal and light
            half NdotL = dot(s.Normal, lightDir);
            
            half halfLambert = NdotL * 0.5+0.5;
            
            half3 color = s.Albedo * _LightColor0.rgb * halfLambert;
            
            return fixed4(color,1);
        }
        void surf (Input IN, inout SurfaceOutput o) 
        {
            fixed4 c = tex2D (_MainTex, IN.uv_MainTex) * _Color;
            o.Albedo = c.rgb;
        }
        ENDCG
    }
    FallBack &quot;Diffuse&quot;
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;
&lt;h4 id=&quot;3-specularphong&quot;&gt;3. Specular(Phong)&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;/static/assets/img/blog/Specular.png&quot; width=&quot;50%&quot; /&gt;
&lt;img src=&quot;/static/assets/img/blog/Specular_rule.png&quot; width=&quot;40%&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;

  &lt;ul&gt;
    &lt;li&gt;M_spec：material color.&lt;/li&gt;
    &lt;li&gt;S_spec：light source color.&lt;/li&gt;
    &lt;li&gt;v · r: the radius of the angle between view direction and the reflection direction of the light direction and normal.&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;In Specular lighting model, shouldn’t use per-vertex-level because it is not accurate with less vertex area.&lt;/p&gt;

&lt;p&gt;(1) &lt;strong&gt;&lt;em&gt;Phong in vertex&amp;amp;fragment Shader&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Shader &quot;MyShader/Specular&quot; 
{
    Properties 
    {
        _Diffuse (&quot;Diffuse&quot;, Color) = (1, 1, 1, 1)
        _Specular (&quot;Specular&quot;, Color) = (1, 1, 1, 1)
        _Gloss (&quot;Gloss&quot;, Range(8.0, 256)) = 20
    }
    SubShader 
    {
        Pass 
        { 
            Tags { &quot;LightMode&quot;=&quot;ForwardBase&quot; }
        
            CGPROGRAM
            
            #pragma vertex vert
            #pragma fragment frag

            #include &quot;Lighting.cginc&quot;
            
            fixed4 _Diffuse;
            fixed4 _Specular;
            float _Gloss;
            
            struct a2v 
            {
                float4 vertex : POSITION;
                float3 normal : NORMAL;
            };
            
            struct v2f 
            {
                float4 pos : SV_POSITION;
                float3 worldNormal : TEXCOORD0;
                float3 worldPos : TEXCOORD1;
            };
            
            v2f vert(a2v v) 
            {
                v2f o;
                // Transform the vertex from object space to projection space
                o.pos = mul(UNITY_MATRIX_MVP, v.vertex);
                
                // Transform the normal from object space to world space
                o.worldNormal = mul(v.normal, (float3x3)_World2Object);
                // Transform the vertex from object spacet to world space
                o.worldPos = mul(_Object2World, v.vertex).xyz;
                
                return o;
            }
            
            fixed4 frag(v2f i) : SV_Target 
            {
                // Get ambient term
                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;
                
                fixed3 worldNormal = normalize(i.worldNormal);
                fixed3 worldLightDir = normalize(_WorldSpaceLightPos0.xyz);
                
                // Compute diffuse term
                fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * saturate(dot(worldNormal, worldLightDir));
                
                // Get the reflect direction in world space
                fixed3 reflectDir = normalize(reflect(-worldLightDir, worldNormal));
                // Reflection can be calculate as below:
                //      float NdotL = dot(worldNormal,worldLightDir);
                //      float reflectDir = normalize(2.0 * worldNormal * NdotL - worldLightDir);
                
                // Get the view direction in world space
                fixed3 viewDir = normalize(_WorldSpaceCameraPos.xyz - i.worldPos.xyz);
                // Compute specular term
                fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(saturate(dot(reflectDir, viewDir)), _Gloss);
                
                return fixed4(ambient + diffuse + specular, 1.0);
            }
            ENDCG
        }
    } 
    FallBack &quot;Specular&quot;
} 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;(2) &lt;strong&gt;&lt;em&gt;Phong in Unity Surface Shader&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Shader &quot;MyShader/SurfaceShader_Phong&quot; 
{
    Properties 
    {
        _Color (&quot;Color&quot;, Color) = (1,1,1,1)
        _MainTex (&quot;Albedo (RGB)&quot;, 2D) = &quot;white&quot; {}
        _SpecularColor(&quot;Specular Color&quot;,Color) = (1,1,1,1)
        _SpecPower(&quot;Specular Power&quot;,Range(0,30)) =1
    }
    SubShader 
    {
        Tags { &quot;RenderType&quot;=&quot;Opaque&quot; }

        CGPROGRAM
        #pragma surface surf Phong
        
        sampler2D _MainTex;
        fixed4 _Color;
        fixed4 _SpecularColor;
        float _SpecPower;

        struct Input
        {
            float2 uv_MainTex;
        };
        
        // Custom Lighting Model
        fixed4 LightingPhong(SurfaceOutput s, fixed3 lightDir,fixed3 viewDir, fixed atten)
        {
            // Diffuse  
            half NdotL = dot(s.Normal, lightDir);
            float3 diffuse = max(0,NdotL) * atten;
            
            // Reflection
            float3 reflectDir = normalize(2.0*s.Normal*NdotL-lightDir);
            
            //Specular
            float spec = pow(max(0,dot(reflectDir,viewDir)),_SpecPower);
            float3 finalSpec = _SpecularColor.rgb*spec;
            
            // Final Effect
            half3 color = s.Albedo * _LightColor0.rgb * diffuse +(_LightColor0*finalSpec);
            
            return fixed4(color,1);
        }
        void surf (Input IN, inout SurfaceOutput o) 
        {
            fixed4 c = tex2D (_MainTex, IN.uv_MainTex) * _Color;
            o.Albedo = c.rgb;
        }
        ENDCG
    }
    FallBack &quot;Diffuse&quot;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;
&lt;h4 id=&quot;4-blinn-phong&quot;&gt;4. Blinn-Phong&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/static/assets/img/blog/blinn-phong.png&quot; width=&quot;50%&quot; /&gt;
&lt;img src=&quot;/static/assets/img/blog/blinn-rule.png&quot; width=&quot;40%&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;

  &lt;ul&gt;
    &lt;li&gt;h(halfway):  h is the middle vector between view direction and light direction (just like the axis of symmetry).&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;(1) &lt;strong&gt;&lt;em&gt;Blinn-Phong in vertex&amp;amp;fragment Shader&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Shader &quot;MyShader/Blinn-Phong&quot;
{
    Properties 
    {
        _Diffuse (&quot;Diffuse&quot;, Color) = (1, 1, 1, 1)
        _Specular (&quot;Specular&quot;, Color) = (1, 1, 1, 1)
        _Gloss (&quot;Gloss&quot;, Range(8.0, 256)) = 20
    }
    SubShader 
    {
        Pass 
        { 
            Tags { &quot;LightMode&quot;=&quot;ForwardBase&quot; }
            CGPROGRAM
            
            #pragma vertex vert
            #pragma fragment frag
            
            #include &quot;Lighting.cginc&quot;
            
            fixed4 _Diffuse;
            fixed4 _Specular;
            float _Gloss;
            
            struct a2v 
            {
                float4 vertex : POSITION;
                float3 normal : NORMAL;
            };
            
            struct v2f 
            {
                float4 pos : SV_POSITION;
                float3 worldNormal : TEXCOORD0;
                float3 worldPos : TEXCOORD1;
            };
            
            v2f vert(a2v v) 
            {
                v2f o;
                // Transform the vertex from object space to projection space
                o.pos = mul(UNITY_MATRIX_MVP, v.vertex);
                
                // Transform the normal from object space to world space
                o.worldNormal = mul(v.normal, (float3x3)_World2Object);
                
                // Transform the vertex from object spacet to world space
                o.worldPos = mul(_Object2World, v.vertex).xyz;
                
                return o;
            }
            
            fixed4 frag(v2f i) : SV_Target 
            {
                // Get ambient term
                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;
                
                fixed3 worldNormal = normalize(i.worldNormal);
                fixed3 worldLightDir = normalize(_WorldSpaceLightPos0.xyz);
                
                // Compute diffuse term
                fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * max(0, dot(worldNormal, worldLightDir));
                
                // Get the view direction in world space
                fixed3 viewDir = normalize(_WorldSpaceCameraPos.xyz - i.worldPos.xyz);
                // Get the half direction in world space
                fixed3 halfDir = normalize(worldLightDir + viewDir);
                // Compute specular term
                fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(max(0, dot(worldNormal, halfDir)), _Gloss);
                
                return fixed4(ambient + diffuse + specular, 1.0);
            }  
            ENDCG
        }
    } 
    FallBack &quot;Specular&quot;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;(2) &lt;strong&gt;&lt;em&gt;Blinn-Phong in Unity Surface Shader&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
Shader &quot;MyShader/SurfaceShader_BilnnPhong&quot; 
{
    Properties 
    {
        _Color (&quot;Color&quot;, Color) = (1,1,1,1)
        _MainTex (&quot;Albedo (RGB)&quot;, 2D) = &quot;white&quot; {}
        _SpecularColor(&quot;Specular Color&quot;,Color) = (1,1,1,1)
        _SpecPower(&quot;Specular Power&quot;,Range(8,255)) =1
	}
    SubShader 
    {
        Tags { &quot;RenderType&quot;=&quot;Opaque&quot; }

        CGPROGRAM
        #pragma surface surf CustomBlinnPhong
        
        sampler2D _MainTex;
        fixed4 _Color;
        fixed4 _SpecularColor;
        float _SpecPower;

        struct Input
        {
            float2 uv_MainTex;
        };
        
        // Custom Lighting Model
        half4 LightingCustomBlinnPhong(SurfaceOutput s, fixed3 lightDir, half3 viewDir, half atten)
        {
            // Get the dot product of normal and light
            half NdotL = dot(s.Normal, lightDir);
            
            half3 diffuse = _LightColor0.rgb * _Color.rgb * saturate(NdotL);
           
            // Get the direction between lighrDir and viewDir
            half3 halfDir = normalize(lightDir + viewDir);
            half NdotH = dot(s.Normal, halfDir);
            
            half3 specular = _LightColor0.rgb * _SpecularColor.rgb * pow(max(0,NdotH), _SpecPower);
            half3 color =s.Albedo * diffuse +specular;
            
            return half4(color,1);
        }
        void surf (Input IN, inout SurfaceOutput o) 
        {
            fixed4 c = tex2D (_MainTex, IN.uv_MainTex) * _Color;
            o.Albedo = c.rgb;
        }
        ENDCG
    }
	FallBack &quot;Diffuse&quot;
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;End –Cheng Gu&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

</description>
        <pubDate>Tue, 05 Jun 2018 00:00:00 -0700</pubDate>
        <link>http://localhost:4000/cg/unity/2018/06/05/Lighting-Models.html</link>
        <guid isPermaLink="true">http://localhost:4000/cg/unity/2018/06/05/Lighting-Models.html</guid>
        
        <category>Unity</category>
        
        <category>Shader</category>
        
        <category>Math</category>
        
        <category>CG</category>
        
        
        <category>Cg</category>
        
        <category>Unity</category>
        
      </item>
    
      <item>
        <title>Trig In Game World</title>
        <description>&lt;p&gt;In this post mainly talks about two parts of trigonometry in game development. Respectively They are Trignometry Unit Circle vs Unity Unit Circle &amp;amp; ATan(y/x) vs ATan2(y,x)&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;     
&lt;img src=&quot;/static/assets/img/blog/trig.jpg&quot; width=&quot;80%&quot; /&gt;
&lt;/p&gt;

&lt;hr /&gt;
&lt;h4 id=&quot;1-difference-in-math--game&quot;&gt;1. Difference in Math &amp;amp; Game&lt;/h4&gt;

&lt;p align=&quot;center&quot;&gt;     
&lt;img src=&quot;/static/assets/img/blog/diff_game_math.png&quot; width=&quot;80%&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;Due to in game development, the forward direction should be a start point. Just like the Picture, the Trig Unit Circle need to rotate counterclockwise 90 degrees to the Unity’s Unit Circle.&lt;/p&gt;

&lt;p&gt;eg:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; public float angleInDegrees;

    void Update()
    {
        Vector3 dir = new Vector3(Mathf.Cos((90-angleInDegrees) * Mathf.Deg2Rad), 0, Mathf.Sin((90-angleInDegrees) * Mathf.Deg2Rad));
        Debug.DrawRay(transform.position, dir * 3, Color.cyan);
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Also, the difference between sin and cos is 90 degree, which shows that you can simply swap the &lt;strong&gt;&lt;em&gt;sin&lt;/em&gt;&lt;/strong&gt; and &lt;strong&gt;&lt;em&gt;cos&lt;/em&gt;&lt;/strong&gt; to convert from Trig Unit Circle to Game Development Unit Circle:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    public float angleInDegrees;

    void Update()
    {
        Vector3 dir = new Vector3(Mathf.Sin(angleInDegrees * Mathf.Deg2Rad), 0, Mathf.Cos(angleInDegrees * Mathf.Deg2Rad));
        Debug.DrawRay(transform.position, dir * 3, Color.cyan);
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;
&lt;h4 id=&quot;2-trig-functions-in-cg-world&quot;&gt;2. Trig Functions in CG World&lt;/h4&gt;

&lt;p align=&quot;center&quot;&gt;     
&lt;img src=&quot;/static/assets/img/blog/functions.png&quot; width=&quot;80%&quot; /&gt;
&lt;/p&gt;

&lt;blockquote style=&quot;color: red&quot;&gt;
  &lt;p&gt;In game development though, it can happen fairly often that the adjacent side is equal to 0 (e.g. the x coordinate of a vector being 0). Remembering that tan(angle) = opposite/adjacent the potential for a disastrous divide-by-zero error should be clear. So a lot of libraries offer a function called atan2, which lets you specify both the x and y parameters, to avoid the division by &lt;strong&gt;&lt;em&gt;0&lt;/em&gt;&lt;/strong&gt; for you and give an angle in the right quadrant.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;End –Cheng Gu&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

</description>
        <pubDate>Tue, 29 May 2018 00:00:00 -0700</pubDate>
        <link>http://localhost:4000/math/unity/csharp/2018/05/29/Trig-In-Game-World.html</link>
        <guid isPermaLink="true">http://localhost:4000/math/unity/csharp/2018/05/29/Trig-In-Game-World.html</guid>
        
        <category>Unity</category>
        
        <category>Csharp</category>
        
        <category>Math</category>
        
        <category>CG</category>
        
        <category>Game Dev</category>
        
        
        <category>Math</category>
        
        <category>Unity</category>
        
        <category>Csharp</category>
        
      </item>
    
      <item>
        <title>Matrix TRS</title>
        <description>&lt;p&gt;Normally when we develop programs, unavoidably want to do all sorts of transformation processing to the image. Especically the transformation bewtween multiple coordinate system.&lt;/p&gt;

&lt;p&gt;It is not only complicated but also inefficient. We can combine multiple transformations by using transformation matrix and matrix multiplication. Finally, we can get the desired result by using a matrix for each point.&lt;/p&gt;

&lt;blockquote style=&quot;color: red&quot;&gt;
  &lt;p&gt;Important Note: The order of Transformation does affect the result. In most cases, The order of Matrix Transformation is &lt;strong&gt;&lt;em&gt;Scale -&amp;gt; Rotate -&amp;gt; Translate&lt;/em&gt;&lt;/strong&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p align=&quot;center&quot;&gt;   
&lt;img src=&quot;/static/assets/img/blog/matrix_rts.png&quot; width=&quot;80%&quot; /&gt;
&lt;/p&gt;

&lt;hr /&gt;
&lt;h4 id=&quot;1-translate-t&quot;&gt;1. Translate (T)&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/static/assets/img/blog/t.png&quot; width=&quot;30%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;eg:Translate (3, -2, 1.5) from a start point (2, 3, 5)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    public Matrix4x4 matrix;
    public Vector4 vector;
    void Start()
    {
        // if the w is 1 represent a point, 0 represent a vector
        vector = new Vector4(transform.position.x, transform.position.y, transform.position.z, 1);
        matrix = Matrix4x4.identity;
        Debug.Log(&quot;Before Translate: &quot; + transform.localToWorldMatrix);
        //Before Translate: 
        //    1.00000	0.00000	0.00000	2.00000
        //    0.00000	1.00000	0.00000	3.00000
        //    0.00000	0.00000	1.00000	5.00000
        //    0.00000	0.00000	0.00000	1.00000
        
        
        matrix.m03 = 3; // move (3,-2,1.5)
        matrix.m13 = -2;
        matrix.m23 = 1.5f;
        
        
        // Translate
        vector = matrix * vector;
        transform.position = new Vector3(vector.x, vector.y, vector.z);
        Debug.Log(&quot;After Translate: &quot; + transform.localToWorldMatrix);
        //After Translate: 
        //    1.00000	0.00000	0.00000	5.00000
        //    0.00000	1.00000	0.00000	1.00000
        //    0.00000	0.00000	1.00000	6.50000
        //    0.00000	0.00000	0.00000	1.00000
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;
&lt;h4 id=&quot;2-rotate-r&quot;&gt;2. Rotate (R)&lt;/h4&gt;
&lt;p&gt;(1) Rotate Along X-Axis:
In 3D, when P(x,y,z) rotate along the x-axis and got P’(x’,y’,z’). x will not change. the Y and Z composite a plane with O (the origin) - &lt;strong&gt;&lt;em&gt;YOZ&lt;/em&gt;&lt;/strong&gt; so:
   x′=x 
   y′=ycosθ−zsinθ 
   z′=ysinθ+zcosθ&lt;/p&gt;

&lt;p&gt;Normally use Matrix4X4 represent this transformation:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/assets/img/blog/r_x.png&quot; width=&quot;30%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;(2) Rotate Along Z-Axis:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/assets/img/blog/r_z.png&quot; width=&quot;30%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;(3) Rotate Along Y-Axis:
when P(x,y,z) rotate along the y-axis got P’(x’,y’,z’). y will not change. the ZOX composite a plane&lt;strong&gt;&lt;em&gt;(NOT XOZ)&lt;/em&gt;&lt;/strong&gt; so:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/assets/img/blog/r_y.png&quot; width=&quot;30%&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;Above Described the roation in matrix. These three are all similar except rotating along the y-axis. The reason is the y-axis have a different axial order.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;XYZ —Along x-axis&lt;/li&gt;
  &lt;li style=&quot;color: red&quot;&gt;YZX —Along y-axis (NOT YXZ, Order changed)&lt;/li&gt;
  &lt;li&gt;ZXY —Along z-axis&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;So, when rotating along y-axis,&lt;/p&gt;

&lt;p&gt;it should transpose from &lt;strong&gt;[x y z 1]&lt;/strong&gt; =&amp;gt;
&lt;img src=&quot;/static/assets/img/blog/y_r_format.png&quot; width=&quot;10%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;eg: rotate along respectively x, y, z 30 degree:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    Matrix4x4 matrix;
    Vector4 vector;
    public float angle = 30;

    public enum Axis { X, Y, Z }
    public Axis axis;

    void Start()
    {
        matrix = Matrix4x4.identity;
        Debug.Log(&quot;Before Rotate: &quot; + matrix);
        //Before Rotate: 1.00000  0.00000 0.00000 0.00000
        //               0.00000 1.00000 0.00000 0.00000
        //               0.00000 0.00000 1.00000 0.00000
        //               0.00000 0.00000 0.00000 1.00000
        switch (axis)
        {
            case Axis.X:
                matrix.m11 = Mathf.Cos(angle * Mathf.Deg2Rad);
                matrix.m12 = -Mathf.Sin(angle * Mathf.Deg2Rad);
                matrix.m21 = Mathf.Sin(angle * Mathf.Deg2Rad);
                matrix.m22 = Mathf.Cos(angle * Mathf.Deg2Rad);
                Debug.Log(&quot;After Rotate(along x-axis) : &quot; + matrix);

                //After Rotate(along x-axis):   1.00000   0.00000   0.00000   0.00000
                //                              0.00000   0.86603  -0.50000   0.00000
                //                              0.00000   0.50000   0.86603   0.00000
                //                              0.00000   0.00000   0.00000   1.00000

                break;
            case Axis.Y:
                matrix.m01 = Mathf.Cos(angle * Mathf.Deg2Rad);
                matrix.m02 = Mathf.Sin(angle * Mathf.Deg2Rad);
                matrix.m21 = -Mathf.Sin(angle * Mathf.Deg2Rad);
                matrix.m22 = Mathf.Cos(angle * Mathf.Deg2Rad);
                Debug.Log(&quot;After Rotate(along y-axis): &quot; + matrix);
                //After Rotate(along y-axis):   1.00000   0.86603   0.50000   0.00000
                //                              0.00000   1.00000   0.00000   0.00000
                //                              0.00000   -0.50000  0.86603   0.00000
                //                              0.00000   0.00000   0.00000   1.00000
                break;
            case Axis.Z:
                matrix.m01 = Mathf.Cos(angle * Mathf.Deg2Rad);
                matrix.m02 = -Mathf.Sin(angle * Mathf.Deg2Rad);
                matrix.m11 = Mathf.Sin(angle * Mathf.Deg2Rad);
                matrix.m12 = Mathf.Cos(angle * Mathf.Deg2Rad);
                Debug.Log(&quot;After Rotate(along z-axis): &quot; + matrix);

                //After Rotate(along z-axis):   1.00000   0.86603  -0.50000   0.00000
                //                              0.00000   0.50000   0.86603   0.00000
                //                              0.00000   0.00000   1.00000   0.00000
                //                              0.00000   0.00000   0.00000   1.00000
                break;
        }

        transform.rotation = MatrixToQuaternion(matrix);
    }

    Quaternion MatrixToQuaternion(Matrix4x4 _matrix)
    {
        float qw = Mathf.Sqrt(1f + _matrix.m00 + _matrix.m11 + _matrix.m22) / 2;
        float w = 4 * qw;
        float qx = (_matrix.m21 - _matrix.m12) / w;
        float qy = (_matrix.m02 - _matrix.m20) / w;
        float qz = (_matrix.m10 - _matrix.m01) / w;

        return new Quaternion(qx, qy, qz, qw);
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;
&lt;h4 id=&quot;3-scale-s&quot;&gt;3. Scale (S)&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/static/assets/img/blog/s.png&quot; width=&quot;30%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;eg: scale (1.5, 2, 3) from the atart scale (1, 1, 1)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; public Matrix4x4 matrix;
    public Vector4 vector;

    void Start()
    {
        Debug.Log(&quot;Before scale: &quot; + transform.localToWorldMatrix);
        //Before scale: 1.00000   0.00000 0.00000 2.00000
        //              0.00000 1.00000 0.00000 3.00000
        //              0.00000 0.00000 1.00000 5.00000
        //              0.00000 0.00000 0.00000 1.00000


        matrix = Matrix4x4.identity;

        // if the w is 1 represent a point, 0 represent a vector
        vector = new Vector4(transform.localScale.x, transform.localScale.y, transform.localScale.z, 1);

        //scale times
        matrix.m00 = 1.5f; // scale x
        matrix.m11 = 2; // scale y
        matrix.m22 = 3; // scale z

        vector = matrix * vector;
        transform.localScale = new Vector3(vector.x, vector.y, vector.z);
        Debug.Log(&quot;After scale: &quot; + transform.localToWorldMatrix);

        //After scale: 1.50000    0.00000 0.00000 2.00000
        //             0.00000 2.00000 0.00000 3.00000
        //             0.00000 0.00000 3.00000 5.00000
        //             0.00000 0.00000 0.00000 1.00000
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;End –Cheng Gu&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

</description>
        <pubDate>Fri, 25 May 2018 00:00:00 -0700</pubDate>
        <link>http://localhost:4000/math/unity/csharp/2018/05/25/RTS-in-Matrix.html</link>
        <guid isPermaLink="true">http://localhost:4000/math/unity/csharp/2018/05/25/RTS-in-Matrix.html</guid>
        
        <category>Unity</category>
        
        <category>Csharp</category>
        
        <category>Math</category>
        
        <category>CG</category>
        
        
        <category>Math</category>
        
        <category>Unity</category>
        
        <category>Csharp</category>
        
      </item>
    
      <item>
        <title>Cross Or Dot</title>
        <description>&lt;p&gt;The Cross Product and the Dot Product are the most common calculations of Vector. In the Game Development, it is necessary to understand both of them. The biggest difference between them is that:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;The result of &lt;strong&gt;dot product&lt;/strong&gt; is a &lt;strong&gt;value&lt;/strong&gt;
The result of &lt;strong&gt;cross product&lt;/strong&gt; is a &lt;strong&gt;vector&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;
&lt;h2 id=&quot;1-dot-product&quot;&gt;&lt;strong&gt;1. Dot Product&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;The dot product of two n-dimensional vectors A and B, written as A ⋅ B, is the scalar quantity given by the formula:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\Huge A\cdot B = \sum_{i=1}^{n}{A_i}{B_i}&lt;/script&gt;

&lt;p&gt;eg:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;if:&lt;/strong&gt;&lt;br /&gt;
&lt;script type=&quot;math/tex&quot;&gt;\large \qquad Vector3\:\: v_1 = (x_1,y_1,z_1), Vector3\:\: v_2 = (x_2,y_2,z_2)&lt;/script&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;then:&lt;/strong&gt;&lt;br /&gt;
&lt;script type=&quot;math/tex&quot;&gt;\large \qquad v_1 \cdot v_2 = {x_1}{x_2}+{y_1}{y_2}+{z_1}{z_2}&lt;/script&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Follow the law of trig it can write as:&lt;br /&gt;
&lt;script type=&quot;math/tex&quot;&gt;\large \qquad A\cdot B = \|A\|\|B\| cos\theta&lt;/script&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Follow up, it also can write as:&lt;br /&gt;
&lt;script type=&quot;math/tex&quot;&gt;\large\qquad\theta = acos (\frac{A\cdot B}{\|A\|\|B\| })&lt;/script&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The position relation of two vectors can be determined by the sign of the dot product of these two vector.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;If the dot product = 0, these two vectors are perpendicular. Two Vector point &lt;strong&gt;mostly same direction&lt;/strong&gt;.&lt;/li&gt;
  &lt;li&gt;If the dot product &amp;lt;0, the angle between two Vector is 90 ~ 180. Two Vector &lt;strong&gt;perpendicular&lt;/strong&gt;.&lt;/li&gt;
  &lt;li&gt;If the dot product &amp;gt;0, the angle between two Vector is 0 ~ 90. Two Vector point &lt;strong&gt;mostly opposite direction&lt;/strong&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The dot product A ⋅ B may also be expressed as the &lt;strong&gt;matrix product&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;\begin{equation} A_T B = \begin{bmatrix}A_1 &amp;amp; A_2 &amp;amp; \cdots &amp;amp; A_n\end{bmatrix} \begin{bmatrix}B_1 \\ B_2 \\ \vdots \\ B_n\end{bmatrix} \end{equation}&lt;/p&gt;

&lt;p&gt;Dot Product also can calculate the &lt;strong&gt;projection&lt;/strong&gt; of a vector by giving A and B vectors:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;script type=&quot;math/tex; mode=display&quot;&gt;proj_BA = \frac{A\cdot B}{\|B\|}&lt;/script&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h4 id=&quot;example-in-game-development&quot;&gt;&lt;strong&gt;&lt;em&gt;Example in Game Development:&lt;/em&gt;&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;(1) Get the Angle of two vectors: range [0, 180], whether the view of the game monster can be viewed to the player, and can be used to calculate whether the enemy is within the range of the character’s attack.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Vector A,B;
float dotValue = Vector3.Dot (A.normalized, B.normalized);
float angle = Mathf.Acos(dotValue) * Mathf.Rad2Deg;  
//However. there is a easier way to do it in unity by using Vector.Angle().
//float angle= Vector3.Angle (Vector3 from, Vector3 to) 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;(2) Determine if the target is in front of you, or behind you.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;float dotValue=Vector3.Dot(transform.forward, target.position)
if(dotValue&amp;gt;0)
{
    print(&quot;Target is in front of you&quot;);
}else if(dotValue&amp;lt;0)
{
    print(&quot;Target is behind you&quot;);
}else{
    print(&quot;Target is on the left or right.&quot;);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;(3) Simulate the flight status of the aircraft&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;float dotValue = Vector3.Dot(transform.forward, Vector3.up);
if (dotValue &amp;lt; 0)
{
    print(&quot;This plane is flying down&quot;);
}
else if (dotValue &amp;gt; 0)
{
    print(&quot;This plane is flying up&quot;);
}
else
{
    print(&quot;This plane is flying in parallel &quot;);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;
&lt;h2 id=&quot;2-cross-product&quot;&gt;&lt;strong&gt;2. Cross Product&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;The cross product of two three-dimensional vectors, returns a new vector that is perpendicular to both of the vectors being multiplied together. This property has many uses in computer graphics, one of which is a method for calculating a surface normal at a particular point given two distinct tangent vectors.&lt;/p&gt;

&lt;p&gt;The cross product of two 3D vectors A and B, written as A × B, is a vector quantity given by the formula:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\large A×B = (A_yB_z−A_zB_y, A_zB_x−A_xB_z, A_xB_y−A_yB_x)&lt;/script&gt;

&lt;p&gt;This equation seems no regularity, but it has, shown as below:&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;     
&lt;img src=&quot;/static/assets/img/blog/Cross.jpg&quot; width=&quot;50%&quot; /&gt;
&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Follow the law of trig it can write as:&lt;br /&gt;
&lt;script type=&quot;math/tex&quot;&gt;\large \qquad \|A×B\|=\|A\|\|B\|sin\theta&lt;/script&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Follow up, it also can write as:&lt;br /&gt;
&lt;script type=&quot;math/tex&quot;&gt;\large \qquad \theta = asin (\frac{\|A×B\|}{\|A\|\|B\| })&lt;/script&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The cross product of two vectors, the result of the cross product is a vector instead of a value. Also, the cross product of two vectors is &lt;strong&gt;&lt;em&gt;perpendicular&lt;/em&gt;&lt;/strong&gt; to the coordinate plane of these two vectors.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;In Math, it satisfy right hand rule, a x b = -b x a. So we can use the result of Cross product’s value is positive or negative to determine a and b’s relative position.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p align=&quot;center&quot;&gt;    
&lt;img src=&quot;/static/assets/img/blog/right-hand.jpg&quot; width=&quot;20%&quot; /&gt;&lt;br /&gt;

&lt;b&gt;Right-hand Cooridinate System&lt;/b&gt;
&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;   
&lt;img src=&quot;/static/assets/img/blog/left-hand.jpg&quot; width=&quot;20%&quot; /&gt;&lt;br /&gt;

&lt;b&gt;Left-hand Cooridinate System**&lt;/b&gt;
&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;  
&lt;img src=&quot;/static/assets/img/blog/Cross2.jpg&quot; width=&quot;20%&quot; /&gt;&lt;br /&gt;

&lt;b&gt;Normal vector of a plane is the Cross Product of the coordinate plane of x and y vectors.**&lt;/b&gt;
&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h4 id=&quot;example-in-game-development-1&quot;&gt;&lt;strong&gt;&lt;em&gt;Example in Game Development:&lt;/em&gt;&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;(1) WallWalking:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt; The core is to use cross product cauculate the normal of wall's plane, and ground plane's normal to implement into player's Up direction
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;(2) Determine the target is on your right or left:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt; if return a negative value, the target is on the left,
if return a positive value, the target is on the right,
if return 0, the the target is on the front side or back side
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Vector3.Cross(transform.forward, target.position).y&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;(3) Get the area size of a parallelogram which formed by 2 objects&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;S = |b| * |a| * sin(θ)&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;(4) Get the angle between two vectors&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Vector3 a, b;
float value = Vector3.Cross(a.normalized, b.normalized);
float angle = Mathf.Asin(value) * Mathf.Rad2Deg;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;(5) Can Determine if two vector is &lt;strong&gt;Parallel&lt;/strong&gt; or &lt;strong&gt;Intersecting&lt;/strong&gt;.&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;In conclusion, &lt;strong&gt;&lt;em&gt;Dot Product&lt;/em&gt;&lt;/strong&gt; determine the angle of two Vectors, &lt;strong&gt;&lt;em&gt;Cross Product&lt;/em&gt;&lt;/strong&gt; determine the direction of two Vectors.&lt;/p&gt;

&lt;p&gt;For instance, when an enemy behind you, &lt;strong&gt;&lt;em&gt;Cross Product&lt;/em&gt;&lt;/strong&gt; determine whether you should turn left or turn right to face to the enemy quickly; the &lt;strong&gt;&lt;em&gt;Dot Product&lt;/em&gt;&lt;/strong&gt; can get the angle size you need to turn towards the enemy.&lt;/p&gt;

&lt;hr /&gt;
&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;End –Cheng Gu&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

</description>
        <pubDate>Sun, 20 May 2018 00:00:00 -0700</pubDate>
        <link>http://localhost:4000/math/unity/csharp/2018/05/20/The-Cross-Product-and-the-Dot-Product-in-Unity.html</link>
        <guid isPermaLink="true">http://localhost:4000/math/unity/csharp/2018/05/20/The-Cross-Product-and-the-Dot-Product-in-Unity.html</guid>
        
        <category>Unity</category>
        
        <category>Csharp</category>
        
        <category>Math</category>
        
        <category>CG</category>
        
        
        <category>Math</category>
        
        <category>Unity</category>
        
        <category>Csharp</category>
        
      </item>
    
      <item>
        <title>Suzuka Wants to Fly Game Development Journal</title>
        <description>&lt;p&gt;This is a third person spiderman style game demo. Because many people will have motion sickness when they are playing a game with faster visual change in Virtual Reality.&lt;/p&gt;

&lt;p&gt;I used a third person view spiderman style swinging game demo to try to discover a new world in visual reality for reducing this adverse consequences. I also want to use this chance to practice my programming abilities. That’s the goal for me to create this project.&lt;/p&gt;

&lt;p&gt;In this Project, I my own third person controling system for my first anime Character called Suzuka, with swinging moving, wall walking, battle system, and wallwalking machanics (compatible with HTC Vive). Also, I created a infinite city generator instead of wasting time on level design.&lt;/p&gt;

&lt;iframe width=&quot;800&quot; height=&quot;600&quot; src=&quot;https://www.bilibili.com/video/av37162427&quot; frameborder=&quot;0&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;

&lt;hr /&gt;
&lt;h4 id=&quot;1-normal-state-movement&quot;&gt;1. Normal State Movement&lt;/h4&gt;
&lt;p&gt;Player’s movement depends on the input direction. When the player is not moving, the camera is free look, but once player moves, the camera view will look along the player’s moving direction.
When player jump or isn’t grounded, he will always look at the camera’s look direction with a smooth transition. Also, he will gain three abilities:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;Swinging&lt;/strong&gt;: Done with Unity’s Fixed Joint (In the future, it will be improved by using Configuable Joint)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Bursting&lt;/strong&gt;: Done with Unity’s AddForce () function.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;WallWalking&lt;/strong&gt;: Done with Raycasting and Cross Product.&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;
&lt;h4 id=&quot;2-battle-state-movement&quot;&gt;2. Battle State Movement&lt;/h4&gt;
&lt;p&gt;When the player encounter an Enemy, player’s state will change to battle state, and the only way to change state back to normal state is to beat the enemy. Of course, player will not be able to jump, which means he also can’t swing, burst,or walk onto the wall, but he gains weapons from WeaponManager(so far only a hidden blade and a pistol) . Switch weapon can gain different abilities to against enemy.&lt;/p&gt;

&lt;hr /&gt;
&lt;h4 id=&quot;3-infinity-city-generator&quot;&gt;3. Infinity City Generator&lt;/h4&gt;
&lt;p&gt;Also, I created a infinite city generator instead of using a lot of time on level design. (because Level design is a pain) Done by Raycast from each city to detect if there is another city in the front, right, left, back. and based on the player’s distance between the cities to determine “destroy” or “instantiate” Done by object pool.&lt;/p&gt;

&lt;hr /&gt;
&lt;h4 id=&quot;4-enemy-ai-behavior-tree&quot;&gt;4. Enemy AI Behavior Tree&lt;/h4&gt;
&lt;p&gt;So far the enemy has four mental states:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;Chase&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Patrol&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Idle&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Die&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Due to the limition of unity’s NavMeshAgent, it cannot support the procedural generating map. I used waypoints as the Enemy’s movement (in the future maybe using A* Pathfinding Algorithm to achieve this challange). 
I used a Spot light’s angle as the enemy’s detecting range. When the enemy discover the player, he will chase the player. Attacking while being close to the player. Also, in order to prevent enemy go through the wall, I also used LineCast() method to detect if there is something between the player and the enemy when the enemy is chasing the player.&lt;/p&gt;

&lt;hr /&gt;
&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;End –Cheng Gu&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Sat, 12 May 2018 00:00:00 -0700</pubDate>
        <link>http://localhost:4000/game%20dev/unity/csharp/2018/05/12/Suzuka-Wants-to-Fly-Game-Dev-Journal.html</link>
        <guid isPermaLink="true">http://localhost:4000/game%20dev/unity/csharp/2018/05/12/Suzuka-Wants-to-Fly-Game-Dev-Journal.html</guid>
        
        <category>Unity</category>
        
        
        <category>Game dev</category>
        
        <category>Unity</category>
        
        <category>Csharp</category>
        
      </item>
    
  </channel>
</rss>
