<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom"><generator uri="https://jekyllrb.com/" version="3.6.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml"/><link href="http://localhost:4000/" rel="alternate" type="text/html"/><updated>2018-08-29T08:41:55-07:00</updated><id>http://localhost:4000/</id><title type="html">Suzuka Site</title><subtitle>An Otaku who loves making and playing games.</subtitle><entry><title type="html">C# Iterator</title><link href="http://localhost:4000/2018/08/28/CSharp-Iterator/" rel="alternate" type="text/html" title="C# Iterator"/><published>2018-08-28T05:15:05-07:00</published><updated>2018-08-28T05:15:05-07:00</updated><id>http://localhost:4000/2018/08/28/CSharp-Iterator</id><content type="html" xml:base="http://localhost:4000/2018/08/28/CSharp-Iterator/">&lt;p&gt;Iterator can make you get all the elements in a sequence without caring about its type is &lt;strong&gt;&lt;em&gt;Array&lt;/em&gt;&lt;/strong&gt;, &lt;strong&gt;&lt;em&gt;List&lt;/em&gt;&lt;/strong&gt;, or other sequence structure.&lt;/p&gt; &lt;p&gt;In .Net, Iterator is encapsulated by &lt;strong&gt;&lt;em&gt;IEnumerator&lt;/em&gt;&lt;/strong&gt; and their corresponding generic interfaces&lt;strong&gt;&lt;em&gt;IEnumerable&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt; &lt;p&gt;In C#1, it has already supported iterator, which is the &lt;strong&gt;&lt;em&gt;foreach&lt;/em&gt;&lt;/strong&gt; statement. Compared with using for loop to, many times using &lt;strong&gt;&lt;em&gt;foreach&lt;/em&gt;&lt;/strong&gt; will be more easy and strightforward. when doing &lt;strong&gt;&lt;em&gt;foreach&lt;/em&gt;&lt;/strong&gt;, the compiler will compile &lt;strong&gt;&lt;em&gt;foreach&lt;/em&gt;&lt;/strong&gt; to invoke the &lt;strong&gt;&lt;em&gt;GetEnumerator&lt;/em&gt;&lt;/strong&gt; and &lt;strong&gt;&lt;em&gt;MoveNext&lt;/em&gt;&lt;/strong&gt; methods, as well as the &lt;strong&gt;&lt;em&gt;Current&lt;/em&gt;&lt;/strong&gt; property.&lt;/p&gt; &lt;p class=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/PostImages/iterator.png&quot; alt=&quot;dot&quot; height=&quot;80%&quot; width=&quot;80%&quot; /&gt;&lt;/p&gt; &lt;hr /&gt; &lt;h4 id=&quot;1-c-10-implementing-iterators-manually&quot;&gt;1. C# 1.0: Implementing Iterators Manually&lt;/h4&gt; &lt;p&gt;if we want to create a new List Type. Ignore all other details, only focus on the iterator. This List will store the values in array, and this list can set the start point of the iteration. For example, we have 5 elements. We can set start index is 2, the iteration order shoule be 2,3,4,0,1.&lt;/p&gt; &lt;blockquote&gt; &lt;p&gt;Main Program:&lt;/p&gt; &lt;/blockquote&gt; &lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-csharp&quot; data-lang=&quot;csharp&quot;&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MainClass&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;object&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;values&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;a&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;b&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;c&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;d&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;e&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IterationSample&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;collection&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;IterationSample&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;values&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;foreach&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;collection&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;WriteLine&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt; &lt;blockquote&gt; &lt;p&gt;IterationSample Class:&lt;/p&gt; &lt;/blockquote&gt; &lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-csharp&quot; data-lang=&quot;csharp&quot;&gt; &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;IterationSample&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IEnumerable&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;values&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Int32&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;startingPoint&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;IterationSample&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;values&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Int32&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;startingPoint&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;values&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;values&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;startingPoint&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;startingPoint&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// In order to use &quot;foreach&quot; statement, this method is necessary&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IEnumerator&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;GetEnumerator&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;IterationSampleEnumerator&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt; &lt;blockquote&gt; &lt;p&gt;In above code, we implemented IEnumerable Interface, but we haven’t implement the GetEnumerator() method. We can use this &lt;strong&gt;&lt;em&gt;IterationSample&lt;/em&gt;&lt;/strong&gt; class to implement the Ienumerator Interface, and use different functions implements the Iterator’s Logics, but this goes against the principle of single responsibility. So we use another class to implement this.&lt;/p&gt; &lt;/blockquote&gt; &lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-csharp&quot; data-lang=&quot;csharp&quot;&gt; &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;IterationSampleEnumerator&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IEnumerator&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IterationSample&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//object to iterate&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Int32&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;// currentIndex Position&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;internal&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;IterationSampleEnumerator&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IterationSample&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;position&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;MoveNext&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//determine the current position if the last index in the list&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;position&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;values&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;++;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;position&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;values&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Current&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;get&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//not allow to access the first and the last value&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;position&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;position&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;values&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;InvalidOperationException&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// consider the case of custom start position &lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Int32&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;index&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;position&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;startingPoint&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;index&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;index&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;values&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;values&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Reset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;position&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt; &lt;hr /&gt; &lt;h4 id=&quot;2-c-20-implementing-iterators&quot;&gt;2. C# 2.0: Implementing Iterators&lt;/h4&gt; &lt;p&gt;After C# 2.0, it introduced &lt;strong&gt;&lt;em&gt;iterator&lt;/em&gt;&lt;/strong&gt;, and &lt;strong&gt;&lt;em&gt;yield return&lt;/em&gt;&lt;/strong&gt; statements. It becomes much more simplier.&lt;/p&gt; &lt;blockquote&gt; &lt;p&gt;Main Program:&lt;/p&gt; &lt;/blockquote&gt; &lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-csharp&quot; data-lang=&quot;csharp&quot;&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MainClass&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;object&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;values&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;a&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;b&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;c&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;d&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;e&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IterationSample&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;collection&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;IterationSample&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;values&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;foreach&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;collection&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;WriteLine&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt; &lt;blockquote&gt; &lt;p&gt;IterationSample Class:&lt;/p&gt; &lt;/blockquote&gt; &lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-csharp&quot; data-lang=&quot;csharp&quot;&gt; &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;IterationSample&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IEnumerable&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;values&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Int32&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;startingPoint&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;IterationSample&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;values&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Int32&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;startingPoint&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;values&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;values&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;startingPoint&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;startingPoint&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// In order to use &quot;foreach&quot; statement, this method is necessary&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IEnumerator&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;GetEnumerator&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;index&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;index&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;values&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;++)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;yield&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;values&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;index&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;startingPoint&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;values&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt; &lt;hr /&gt; &lt;blockquote&gt; &lt;p&gt;&lt;strong&gt;End –Cheng Gu&lt;/strong&gt;&lt;/p&gt; &lt;/blockquote&gt;</content><author><name></name></author><summary type="html">Iterator can make you get all the elements in a sequence without caring about its type is Array, List, or other sequence structure.</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/assets/images/post17.png"/></entry><entry><title type="html">Unity Rendering Path</title><link href="http://localhost:4000/2018/08/14/Unity-Rendering-Path/" rel="alternate" type="text/html" title="Unity Rendering Path"/><published>2018-08-14T05:15:05-07:00</published><updated>2018-08-14T05:15:05-07:00</updated><id>http://localhost:4000/2018/08/14/Unity-Rendering-Path</id><content type="html" xml:base="http://localhost:4000/2018/08/14/Unity-Rendering-Path/">&lt;p&gt;Unity support many kinds of rendering path. In Unity 5.0, there are three types of rendering path: forward, deferred, and vertex lit rendering path.&lt;/p&gt; &lt;hr /&gt; &lt;h4 id=&quot;1-forward-rendering-path&quot;&gt;1. Forward Rendering Path&lt;/h4&gt; &lt;p class=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/PostImages/fwdRendering.png&quot; alt=&quot;dot&quot; height=&quot;80%&quot; width=&quot;80%&quot; /&gt;&lt;/p&gt; &lt;p&gt;For each forward rendering, we need to render the rendering primitive of the object and calculate the data of two buffers (color buffer and depth buffer). We use the depth buffer to determine if a fragment is visible and update the color value of the color buffer if it is visible.&lt;/p&gt; &lt;blockquote&gt; &lt;p&gt;We can use pseudo code to describe the process of forward rendering:&lt;/p&gt; &lt;/blockquote&gt; &lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cg&quot; data-lang=&quot;cg&quot;&gt; Pass { for(each primitive in this model) { for(each fragment covered by this primitive) { if(failed in depth test) { discard; } else { float4 color = Shading(materialInfo, pos, normal, lightDir, viewDir); WriteFrameBuffer(fragment, color); } } } } &lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt; &lt;hr /&gt; &lt;h4 id=&quot;2-deferred-rendering-path&quot;&gt;2. Deferred Rendering Path&lt;/h4&gt; &lt;p class=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/PostImages/deferredrendering.png&quot; alt=&quot;dot&quot; height=&quot;80%&quot; width=&quot;80%&quot; /&gt;&lt;/p&gt; &lt;p&gt;Deferred Rendering mainly includes two Pass. The first Pass, we don’t do any lighting calculations, and only calculate which fragment in the screen is visible, by depth buffer. After finding a fragment is visible, it will store the data into the G-Buffer. Then, in the second Pass, it will use the data of fragment in the G-Buffer to do the lighting calculation.&lt;/p&gt; &lt;blockquote&gt; &lt;p&gt;We can use pseudo code to describe the process of the deferred rendering:&lt;/p&gt; &lt;/blockquote&gt; &lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cg&quot; data-lang=&quot;cg&quot;&gt; PassOne // Store fragment data into G-Buffer { for(each primitive in this model) { for(each fragment covered by this primitive) { if(failed in depth test) { discard; } else { WriteGBuffer(materialInfo, pos, normal, lightDir, viewDir); } } } } PassTwo // Calcaulate Lighting by using the data in G-Buffer { for(each pixel in the screen) { if(the pixel is valid) { readGBuffer(pixel, materialInfo, pos, normal, lightDir, viewDir); float4 color = Shading(materialInfo, pos, normal, lightDir, viewDir); WriteFrameBuffer(pixel, color); } } } &lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt; &lt;hr /&gt; &lt;h4 id=&quot;2-why-use-deferred-rendering&quot;&gt;2. Why use Deferred Rendering&lt;/h4&gt; &lt;blockquote&gt; &lt;p&gt;Normally we will use Forward Rendering, but when the scene has too many light sources, the performance of Forward Rendering drops dramatically.&lt;/p&gt; &lt;/blockquote&gt; &lt;blockquote&gt; &lt;p&gt;For example, if we place multiple light sources in an area in the Unity Scene, and these light source areas overlap and influence with each other. In order to get the final lighting effects, we need to perform multiple Pass for each object in the area to calculate the lighting result of different light source to this object, finally, blend these results in the color buffer to get the final lighting. Therefore, every time when we call a Pass we need to render the object again, but many calculations actually is repeat.&lt;/p&gt; &lt;/blockquote&gt; &lt;blockquote style=&quot;color: red&quot;&gt; &lt;p&gt;Deferred Rendering can solve this problem because it not only uses color buffer, and depth buffer, it also use an additional buffer called G-Buffer (Geometry- Buffer). G-Buffer stores the information of the surface we care (normally it means the surface which is the closest to camera), such as the surface’s Normal, Position, Material Properties used for illumination calculation, etc.&lt;/p&gt; &lt;/blockquote&gt; &lt;hr /&gt; &lt;blockquote&gt; &lt;p&gt;&lt;strong&gt;End –Cheng Gu&lt;/strong&gt;&lt;/p&gt; &lt;/blockquote&gt;</content><author><name></name></author><summary type="html">Unity support many kinds of rendering path. In Unity 5.0, there are three types of rendering path: forward, deferred, and vertex lit rendering path.</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/assets/images/post16.jpg"/></entry><entry><title type="html">Union Find Algorithm</title><link href="http://localhost:4000/2018/08/09/Union-Find-Algorithm/" rel="alternate" type="text/html" title="Union Find Algorithm"/><published>2018-08-09T07:15:05-07:00</published><updated>2018-08-09T07:15:05-07:00</updated><id>http://localhost:4000/2018/08/09/Union%20Find%20Algorithm</id><content type="html" xml:base="http://localhost:4000/2018/08/09/Union-Find-Algorithm/">&lt;p&gt;This article focuses on an algorithm for solving problems such as dynamic connectivity, using a data structure called Union Find.&lt;/p&gt; &lt;p&gt;The Evolutionary history of Union Find is From Quick Find –&amp;gt; Union Find –&amp;gt; Weighted Union Find&lt;/p&gt; &lt;blockquote style=&quot;color: red&quot;&gt; &lt;p&gt;This is the Performance consumption table:&lt;/p&gt; &lt;/blockquote&gt; &lt;p class=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/PostImages/Performance consumption table.png&quot; alt=&quot;dot&quot; height=&quot;50%&quot; width=&quot;50%&quot; /&gt;&lt;/p&gt; &lt;hr /&gt; &lt;h4 id=&quot;dynamic-connectivity-client&quot;&gt;Dynamic-Connectivity Client&lt;/h4&gt; &lt;blockquote&gt; &lt;p&gt;Code:&lt;/p&gt; &lt;/blockquote&gt; &lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cg&quot; data-lang=&quot;cg&quot;&gt; public static void main(String[] args) { int N = StdIn.readInt(); UF uf = new UF(N); while (!StdIn.isEmpty()) { int p = StdIn.readInt(); int q = StdIn.readInt(); if (!uf.connected(p, q)) { uf.union(p, q); StdOut.println(p + &quot; &quot; + q); } } }&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt; &lt;hr /&gt; &lt;h4 id=&quot;quick-find&quot;&gt;Quick Find&lt;/h4&gt; &lt;p class=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/PostImages/qf.png&quot; alt=&quot;dot&quot; height=&quot;70%&quot; width=&quot;70%&quot; /&gt;&lt;/p&gt; &lt;blockquote&gt; &lt;p&gt;Code:&lt;/p&gt; &lt;/blockquote&gt; &lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cg&quot; data-lang=&quot;cg&quot;&gt; public class QuickFindUF { private int[] id; private int count; public QuickFindUF(int N) { id = new int[N]; count =N; // Set ID of earch object to itself for (int i = 0; i &amp;lt; N; i++) id[i] = i; } // check if p and q are in the same component public boolean connected(int p, int q) { return id[p] == id[q]; } // find the id for the given index public int find(int p) { return id[p]; } public int count() { return count; } // change all id[p] to id[q] public void union(int p, int q) { int pid = id[p]; int qid = id[q]; for (int i = 0; i &amp;lt; id.length; i++) if (id[i] == pid) id[i] = qid; count--; } }&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt; &lt;hr /&gt; &lt;h4 id=&quot;quick-union&quot;&gt;Quick Union&lt;/h4&gt; &lt;p class=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/PostImages/uf.png&quot; alt=&quot;dot&quot; height=&quot;70%&quot; width=&quot;70%&quot; /&gt;&lt;/p&gt; &lt;blockquote&gt; &lt;p&gt;Code:&lt;/p&gt; &lt;/blockquote&gt; &lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cg&quot; data-lang=&quot;cg&quot;&gt; public class QuickUnionUF { private int[] id; private int count; public QuickUnionUF(int N) { id = new int[N]; count =N; // Set ID of earch object to itself for (int i = 0; i &amp;lt; N; i++) id[i] = i; } // check if p and q have same root public boolean connected(int p, int q) { return root(p) == root(q); } // find the id for the given index public int find(int i) { return id[i]; } public int root(int i) { //chase parent pointers until reach root while(i!=id[i]) { // Make every other node in path point to its grandparent id[i] = id[id[i]]; // Pass Compression i = id[i]; } return i; } public int count() { return count; } // change all id[p] to id[q] public void union(int p, int q) { int pRoot = root(p); int qRoot = root(q); if(pRoot == qRoot) return; id[pRoot] = qRoot; // change root of p to point to root of q count--; } }&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt; &lt;hr /&gt; &lt;h4 id=&quot;weighted-quick-union&quot;&gt;Weighted Quick Union&lt;/h4&gt; &lt;p class=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/PostImages/wuf.png&quot; alt=&quot;dot&quot; height=&quot;70%&quot; width=&quot;70%&quot; /&gt;&lt;/p&gt; &lt;blockquote&gt; &lt;p&gt;Code:&lt;/p&gt; &lt;/blockquote&gt; &lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cg&quot; data-lang=&quot;cg&quot;&gt; public class WeightedQuickUnionUF { private int[] id; private int[] size; // to count number of objs in the each root private int count; public WeightedQuickUnionUF(int N) { id = new int[N]; size = new int[N]; count = N; // Set ID of earch object to itself for (int i = 0; i &amp;lt; N; i++) id[i] = i; } // check if p and q have same root public boolean connected(int p, int q) { return root(p) == root(q); } // find the id for the given index public int find(int i) { return id[i]; } public int root(int i) { //chase parent pointers until reach root while(i!=id[i]) { // Make every other node in path point to its grandparent id[i] = id[id[i]]; // Pass Compression i = id[i]; } return i; } public int count() { return count; } // change all id[p] to id[q] public void union(int p, int q) { int pRoot = root(p); int qRoot = root(q); if(pRoot == qRoot) return; // Link root of smaller tree to root of larger tree if(size[pRoot] &amp;lt; size[qRoot]) { id[qRoot] = pRoot;// change root of q to point to root of p size[pRoot] += size[qRoot]; // update the tree size } else { id[pRoot] = qRoot;// change root of p to point to root of q size[qRoot] += size[pRoot]; // update the tree size } count--; } }&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt; &lt;hr /&gt; &lt;h4 id=&quot;comparsion-between-if-it-is-weighted-or-not&quot;&gt;Comparsion between if it is Weighted or not&lt;/h4&gt; &lt;p class=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/PostImages/uf vs wuf.png&quot; alt=&quot;dot&quot; height=&quot;80%&quot; width=&quot;80%&quot; /&gt;&lt;/p&gt; &lt;hr /&gt; &lt;blockquote&gt; &lt;p&gt;&lt;strong&gt;End –Cheng Gu&lt;/strong&gt;&lt;/p&gt; &lt;/blockquote&gt;</content><author><name></name></author><summary type="html">This article focuses on an algorithm for solving problems such as dynamic connectivity, using a data structure called Union Find.</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/assets/images/post15.png"/></entry><entry><title type="html">X-Ray Effect in Shader</title><link href="http://localhost:4000/2018/08/05/X-Ray-Effect-in-Shader/" rel="alternate" type="text/html" title="X-Ray Effect in Shader"/><published>2018-08-05T07:15:05-07:00</published><updated>2018-08-05T07:15:05-07:00</updated><id>http://localhost:4000/2018/08/05/X-Ray%20Effect%20in%20Shader</id><content type="html" xml:base="http://localhost:4000/2018/08/05/X-Ray-Effect-in-Shader/">&lt;p&gt;In many games, we can use special ability to see through the wall. So In this post I am going to make a X-ray effect.&lt;/p&gt; &lt;p&gt;A X-Ray is easy to achieve. basicly, just need to add an additional &lt;code class=&quot;highlighter-rouge&quot;&gt;Pass{}&lt;/code&gt; in shader which the &lt;strong&gt;&lt;em&gt;ZTest&lt;/em&gt;&lt;/strong&gt; should set to &lt;strong&gt;&lt;em&gt;Greater&lt;/em&gt;&lt;/strong&gt;, and the ZWrite should close.&lt;/p&gt; &lt;blockquote&gt; &lt;p&gt;This is the result of the experiment:&lt;/p&gt; &lt;/blockquote&gt; &lt;p class=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/PostImages/X-Ray.gif&quot; alt=&quot;dot&quot; height=&quot;50%&quot; width=&quot;50%&quot; /&gt;&lt;/p&gt; &lt;hr /&gt; &lt;blockquote&gt; &lt;p&gt;Code:&lt;/p&gt; &lt;/blockquote&gt; &lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cg&quot; data-lang=&quot;cg&quot;&gt; Shader &quot;MyShader/Transparent2&quot; { Properties { _MainTex(&quot;MainTex&quot;,2D) = &quot;&quot;{} _Color(&quot;Color&quot;, Color) = (1,1,1,1) _OccPower(&quot;Occlusion Power&quot;, Range(0,2)) = 0.5 _OccColor(&quot;Occlusion Color&quot;, Color) = (1,1,1,1) } SubShader { Tags{&quot;RenderTyoe&quot; = &quot;Transparent&quot; &quot;Queue&quot; = &quot;Transparent&quot;} Pass // This pass is for X-ray { Blend DstAlpha One // When the Z value of the object's pixel is greater //than the Z value of the current camera on the pixel, it will pass Ztest ZTest Greater ZWrite Off CGPROGRAM #pragma vertex vert #pragma fragment frag #include &quot;UnityCG.cginc&quot; float _OccPower; fixed4 _OccColor; struct appdata { float4 vertex : POSITION; float3 normal : NORMAL; }; struct v2f { float3 worldNormal : TEXCOORD0; float4 pos : SV_POSITION; float4 worldVertex : TEXCOORD1; }; v2f vert (appdata v) { v2f o; o.pos = UnityObjectToClipPos(v.vertex); o.worldNormal = normalize(mul(v.normal,unity_WorldToObject)); o.worldVertex = normalize(mul(unity_ObjectToWorld, v.vertex)); return o; } fixed4 frag (v2f i) : SV_Target { float3 viewDir = normalize(_WorldSpaceCameraPos.xyz - i.worldVertex.xyz); // rim effect float rim = 1-saturate(dot(i.worldNormal,viewDir)); fixed3 col = pow(rim, _OccPower) * _OccColor.rgb; return fixed4(col,0.5f); } ENDCG } Pass // This pass is for the model itself { Blend SrcAlpha OneMinusSrcAlpha ZWrite On ZTest LEqual CGPROGRAM #pragma vertex vert #pragma fragment frag #include &quot;UnityCG.cginc&quot; struct appdata { float4 vertex : POSITION; float2 uv : TEXCOORD0; }; struct v2f { float2 uv : TEXCOORD0; float4 vertex : SV_POSITION; }; sampler2D _MainTex; float4 _MainTex_ST; fixed4 _Color; v2f vert (appdata v) { v2f o; o.vertex = UnityObjectToClipPos(v.vertex); o.uv = TRANSFORM_TEX(v.uv, _MainTex); return o; } fixed4 frag (v2f i) : SV_Target { // sample the texture fixed3 col = tex2D(_MainTex, i.uv).rgb * _Color.rgb; return fixed4(col,1); } ENDCG } } }&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt; &lt;hr /&gt; &lt;blockquote&gt; &lt;p&gt;&lt;strong&gt;End –Cheng Gu&lt;/strong&gt;&lt;/p&gt; &lt;/blockquote&gt;</content><author><name></name></author><summary type="html">In many games, we can use special ability to see through the wall. So In this post I am going to make a X-ray effect.</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/assets/images/post14.png"/></entry><entry><title type="html">Partial Derivative in Shader</title><link href="http://localhost:4000/2018/08/03/Partial-Derivative-in-Shader/" rel="alternate" type="text/html" title="Partial Derivative in Shader"/><published>2018-08-03T07:15:05-07:00</published><updated>2018-08-03T07:15:05-07:00</updated><id>http://localhost:4000/2018/08/03/Partial%20Derivative%20in%20Shader</id><content type="html" xml:base="http://localhost:4000/2018/08/03/Partial-Derivative-in-Shader/">&lt;p&gt;Currently found a post talked about ddx, and ddy function in shader, so here is a conclusion from that post, and some examples.&lt;/p&gt; &lt;p&gt;This is the &lt;a href=&quot;http://www.aclockworkberry.com/shader-derivative-functions/#footnote_3_1104&quot;&gt;Reference Link&lt;/a&gt;&lt;/p&gt; &lt;hr /&gt; &lt;h4 id=&quot;partial-derivativeddxddy&quot;&gt;Partial Derivative(ddx,ddy)&lt;/h4&gt; &lt;p&gt;In Shader Language, The partial derivative functions are divided into HLSL: ddx and ddy; GLSL:dFdx and dFdy, respectively corresponding to the change rate of various variables in the pixel block in the screen space on the x and y axes.&lt;/p&gt; &lt;p class=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/PostImages/glslPartialDerivative.png&quot; alt=&quot;dot&quot; height=&quot;50%&quot; width=&quot;50%&quot; /&gt;&lt;/p&gt; &lt;p style=&quot;color: red&quot; class=&quot;center&quot;&gt;This image illustrates the calculation of Partial Derivative.&lt;/p&gt; &lt;p&gt;As We know, during the Rasterization, GPUs will run many Fragment shaders in parallel at the same time, but it is not performed pixel by pixel, but by organizing them into a group of pixels at 2x2 pixels to execute in parallel. And the partial derivative is exactly the rate of change in this pixel. It can be seen from the figure above that ddx() is the value of the pixel block on the right minus the value of the pixel block on the left, while ddy is the value of the pixel block below minus the value of the pixel block above. Where x and y represent screen coordinates.&lt;/p&gt; &lt;blockquote&gt; &lt;p&gt;Notices: Partial derivative ddx / ddy can calculate any variable in Fragment Shader. such as Vectors, matrices and so on.&lt;/p&gt; &lt;/blockquote&gt; &lt;hr /&gt; &lt;h4 id=&quot;example-1-derivatives-and-mipmaps-for-uv&quot;&gt;Example 1: Derivatives and mipmaps (For UV)&lt;/h4&gt; &lt;p class=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/PostImages/mipmap.png&quot; alt=&quot;dot&quot; height=&quot;70%&quot; width=&quot;70%&quot; /&gt;&lt;/p&gt; &lt;p&gt;In 3D world, the size of image is related to the location of the camera. When it is close to the camera, the actual pixel of the picture is bigger; when it is far away from the camera, the actual pixel of the picture is smaller. For example, a 64x64 image may show 50&lt;em&gt;50 pixels when it is close to the camera; when it is far away, it may only show 20&lt;/em&gt;20 pixels. So, if the texture pixel is always the orginal number, when it is far away from the camera, this will lead to performance waste.&lt;/p&gt; &lt;p&gt;Mipmap texture Technology is currnetly the most effective way to solve the relationship between texture resolution and the distance between view points. it will first compress images into many progressively smaller images.&lt;/p&gt; &lt;p&gt;“Derivatives are used during texture sampling to select the best mipmap level. The rate of variation of the texture coordinates with respect to the screen coordinates is used to choose a mipmap; the larger the derivatives, the greater the mipmap level (and the lesser the mipmap size).”&lt;/p&gt; &lt;hr /&gt; &lt;h4 id=&quot;example-2-face-normal-computation--flat-shaderfor-vertex&quot;&gt;Example 2: Face normal computation / Flat Shader(For vertex)&lt;/h4&gt; &lt;p&gt;Derivatives can be used to compute the current triangle’s face normal in a fragment shader. The horizontal and vertical derivatives of the current fragment’s world-position are two vectors laying in the triangle’s surface. Their cross product is a vector orthogonal to the surface and its norm is the triangle’s normal vector (see the 3d model below).&lt;/p&gt; &lt;p&gt;Particular attention must be paid to the ordering of the cross product: being the OpenGL coordinate system left-handed (at least when working in window space which is the context where the fragment shader works) and being the horizontal derivative vector always oriented right and the vertical down, the ordering of the cross product to obtain a normal vector oriented toward the camera is horizontal x vertical (more about cross products and basis orientations in this article).&lt;/p&gt; &lt;p&gt;The interactive model below shows the link between screen pixels and fragmets over a triangle surface being rasterized, the derivative vectors on the surface (in red and green), and the normal vector (in blue) obtained by the cross product of the twos.&lt;/p&gt; &lt;p class=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/PostImages/fs1.png&quot; alt=&quot;dot&quot; height=&quot;70%&quot; width=&quot;70%&quot; /&gt;&lt;/p&gt; &lt;blockquote&gt; &lt;p&gt;The normal is shown in Unity shaderlab as follows&lt;/p&gt; &lt;/blockquote&gt; &lt;p class=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/PostImages/fs2.png&quot; alt=&quot;dot&quot; height=&quot;60%&quot; width=&quot;60%&quot; /&gt;&lt;/p&gt; &lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cg&quot; data-lang=&quot;cg&quot;&gt; void surf (Input IN, inout SurfaceOutput o) { o.Albedo = normalize(cross(ddy(IN.worldPos),ddx(IN.worldPos))); }&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt; &lt;hr /&gt; &lt;h4 id=&quot;example-3-sharpen-edge-for-texture&quot;&gt;Example 3: Sharpen Edge (For Texture)&lt;/h4&gt; &lt;p class=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/PostImages/es.png&quot; alt=&quot;dot&quot; height=&quot;70%&quot; width=&quot;70%&quot; /&gt;&lt;/p&gt; &lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cg&quot; data-lang=&quot;cg&quot;&gt; void surf (Input IN, inout SurfaceOutput o) { half4 c = tex2D(_MainTex, IN.uv_MainTex); //The comparsion is depends on this //c += ddx(c)*2 + ddy(c)*2; o.Albedo = c.rgb; o.Alpha = c.a; }&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt; &lt;hr /&gt; &lt;h4 id=&quot;example-4-blur-image-except-the-pixels-which-are-facing-towards-camera&quot;&gt;Example 4: Blur image except the pixels which are facing towards camera&lt;/h4&gt; &lt;p class=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/PostImages/Blur.gif&quot; alt=&quot;dot&quot; height=&quot;70%&quot; width=&quot;70%&quot; /&gt;&lt;/p&gt; &lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cg&quot; data-lang=&quot;cg&quot;&gt;Shader &quot;MyShader/SimpleBlur&quot; { Properties { _MainTex (&quot;Texture&quot;, 2D) = &quot;white&quot; {} } SubShader { Tags { &quot;RenderType&quot;=&quot;Opaque&quot; } Pass { CGPROGRAM #pragma vertex vert #pragma fragment frag #include &quot;UnityCG.cginc&quot; struct appdata { float4 vertex : POSITION; float2 texcoord : TEXCOORD0; }; struct v2f { float4 pos : SV_POSITION; float2 uv : TEXCOORD0; float z : TEXCOORD1; }; sampler2D _MainTex; v2f vert (appdata v) { v2f o; o.pos = UnityObjectToClipPos(v.vertex); o.uv = v.texcoord.xy; o.z = mul(unity_ObjectToWorld, v.vertex).z; return o; } fixed4 frag (v2f i) : SV_Target { float2 dsdx = ddx(i.z)*10; float2 dsdy = ddy(i.z)*10; fixed4 col = tex2D(_MainTex, i.uv, dsdx, dsdy); return col; } ENDCG } } }&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt; &lt;hr /&gt; &lt;blockquote&gt; &lt;p&gt;&lt;strong&gt;End –Cheng Gu&lt;/strong&gt;&lt;/p&gt; &lt;/blockquote&gt;</content><author><name></name></author><summary type="html">Currently found a post talked about ddx, and ddy function in shader, so here is a conclusion from that post, and some examples.</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/assets/images/post13.png"/></entry><entry><title type="html">Dynamic Discoloration Shader</title><link href="http://localhost:4000/2018/07/29/Dynamic-Discoloration-Shader/" rel="alternate" type="text/html" title="Dynamic Discoloration Shader"/><published>2018-07-29T07:15:05-07:00</published><updated>2018-07-29T07:15:05-07:00</updated><id>http://localhost:4000/2018/07/29/Dynamic%20Discoloration%20Shader</id><content type="html" xml:base="http://localhost:4000/2018/07/29/Dynamic-Discoloration-Shader/">&lt;p&gt;An exercise of writing surface shader with vertex function to achieve dynamic discoloration of the model and cube map reflection.&lt;/p&gt; &lt;hr /&gt; &lt;p class=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/PostImages/Model Dynamic Discoloration.gif&quot; alt=&quot;dot&quot; height=&quot;70%&quot; width=&quot;70%&quot; /&gt;&lt;/p&gt; &lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cg&quot; data-lang=&quot;cg&quot;&gt; Shader &quot;MyShader/CarPaint_SurfaceShader&quot; { Properties { _MainColor(&quot;MainColor&quot;,Color) = (1,1,1,1) _SecondColor(&quot;SecondColor&quot;,Color) = (1,1,1,1) _Center(&quot;Center&quot;,Range(-0.7,0.7)) = 0 _Radius(&quot;R&quot;, Range(0,0.5)) = 0.2 _Glossiness (&quot;Smoothness&quot;, Range(0,1)) = 0.5 _Metallic (&quot;Metallic&quot;, Range(0,1)) = 0.0 _MainTex(&quot;Main Texture&quot;,2D) = &quot;&quot;{} _CubeMap(&quot;Cube Map&quot;,Cube)=&quot;&quot;{} } SubShader { Tags { &quot;RenderType&quot;=&quot;Opaque&quot; } CGPROGRAM // Physically based Standard lighting model, and enable shadows on all light types #pragma surface surf Standard fullforwardshadows vertex:vert #pragma target 3.5 // needs it for dx 11 float4 _MainColor; float4 _SecondColor; float _Center; float _Radius; half _Glossiness; half _Metallic; sampler2D _MainTex; samplerCUBE _CubeMap; struct Input { float2 uv_MainTex; float3 R; float z; }; void vert(inout appdata_full v, out Input o) { // UNITY_INITIALIZE_OUTPUT(Input,o); // or o.uv_MainTex = v.texcoord.xy; float3 V = -WorldSpaceViewDir(v.vertex); // float3 V = mul(_Object2World,v.vertex).xyz - _WorldSpaceCameraPos.xyz; // or float3 N = normalize(mul(v.normal,(float3x3)unity_WorldToObject)); o.R = reflect(V,N); o.z = v.vertex.z;// determine the direction the lerp } void surf (Input IN, inout SurfaceOutputStandard o) { // Albedo comes from a texture tinted by color fixed4 c = tex2D (_MainTex, IN.uv_MainTex); fixed4 cubeMapCol = texCUBE(_CubeMap,IN.R); // Combine texture color and the cubemap reflection color o.Albedo = c.rgb + cubeMapCol.rgb; // Metallic and smoothness come from slider variables o.Metallic = _Metallic; o.Smoothness = _Glossiness; o.Alpha = c.a; float d = IN.z - _Center; float dLength = abs(d); // Get 1 or -1 to determine the color on two sides // the vertices &amp;gt; _Center, it will be 1 // the vertices &amp;lt; _Center, it will be -1 d = d / dLength; // The pure level represents the _MainColor and _SecondColor value // when the pureLevel increase, the blending between two color will increase float pureLevel = dLength /_Radius; pureLevel = saturate(pureLevel); // This determine the negative or positive value d *= pureLevel; d = d * 0.5+0.5; o.Albedo *= lerp(_MainColor, _SecondColor, d); } ENDCG } FallBack &quot;Diffuse&quot; }&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt; &lt;hr /&gt; &lt;blockquote&gt; &lt;p&gt;&lt;strong&gt;End –Cheng Gu&lt;/strong&gt;&lt;/p&gt; &lt;/blockquote&gt;</content><author><name></name></author><summary type="html">An exercise of writing surface shader with vertex function to achieve dynamic discoloration of the model and cube map reflection.</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/assets/images/post12.png"/></entry><entry><title type="html">OPP Design Principles</title><link href="http://localhost:4000/2018/07/20/OPP-Programming-Common-Design-Pattern/" rel="alternate" type="text/html" title="OPP Design Principles"/><published>2018-07-20T07:15:05-07:00</published><updated>2018-07-20T07:15:05-07:00</updated><id>http://localhost:4000/2018/07/20/OPP-Programming-Common-Design-Pattern</id><content type="html" xml:base="http://localhost:4000/2018/07/20/OPP-Programming-Common-Design-Pattern/">&lt;p&gt;For making our code system more stable and portability, esay to maintain, follow the solid design principle is significant.&lt;/p&gt; &lt;hr /&gt; &lt;h4 id=&quot;1-srp-single-responsibility-principle&quot;&gt;1. SRP (Single Responsibility Principle)&lt;/h4&gt; &lt;p class=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/PostImages/SRP1.png&quot; alt=&quot;dot&quot; height=&quot;40%&quot; width=&quot;40%&quot; /&gt; &lt;img src=&quot;/assets/images/PostImages/SRP2.png&quot; alt=&quot;dot&quot; height=&quot;40%&quot; width=&quot;38%&quot; /&gt;&lt;/p&gt; &lt;blockquote&gt; &lt;p&gt;&lt;strong&gt;&lt;em&gt;The single responsibility principle (SRP)&lt;/em&gt;&lt;/strong&gt; states that every module or class should have responsibility over a single part of the functionality provided by the software, which means: “When designing to encapsulate a class, the class should be responsible for one kind of function, and all its services should be narrowly aligned with that responsibility”.&lt;/p&gt; &lt;/blockquote&gt; &lt;hr /&gt; &lt;h4 id=&quot;2-ocp-open-closed-principle&quot;&gt;2. OCP (Open-Closed Principle)&lt;/h4&gt; &lt;p class=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/PostImages/OCP.jpg&quot; alt=&quot;dot&quot; height=&quot;70%&quot; width=&quot;70%&quot; /&gt;&lt;/p&gt; &lt;blockquote&gt; &lt;p&gt;&lt;strong&gt;&lt;em&gt;The open/closed principle&lt;/em&gt;&lt;/strong&gt; states “software entities (classes, modules, functions, etc.) should be open for extension, but closed for modification”; that is such an entity can allow its behaviour to be extended without modifying its source code.&lt;/p&gt; &lt;/blockquote&gt; &lt;blockquote&gt; &lt;p&gt;The name open/closed principle has been used in two ways. Both ways use generalizations (for instance, inheritance or delegate functions) to resolve the apparent dilemma, but the goals, techniques, and results are different.&lt;/p&gt; &lt;/blockquote&gt; &lt;hr /&gt; &lt;h4 id=&quot;3-lsp-liskov-substitution-principle&quot;&gt;3. LSP (Liskov Substitution Principle)&lt;/h4&gt; &lt;p class=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/PostImages/LSP.jpg&quot; alt=&quot;dot&quot; height=&quot;60%&quot; width=&quot;60%&quot; /&gt;&lt;/p&gt; &lt;blockquote&gt; &lt;p&gt;Substitutability is a principle in object-oriented programming stating that “A subclass must be able to replace the parent class. “&lt;/p&gt; &lt;/blockquote&gt; &lt;blockquote&gt; &lt;p&gt;For example: There are 3 Classes, Employee, Artist, Programmer. Both Artist and Programmer are the employee, so they should be inherit from Employee Class&lt;/p&gt; &lt;/blockquote&gt; &lt;hr /&gt; &lt;h4 id=&quot;4-dip-dependence-inversion-principle&quot;&gt;4. DIP (Dependence Inversion Principle)&lt;/h4&gt; &lt;p class=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/PostImages/DIP.png&quot; alt=&quot;dot&quot; height=&quot;60%&quot; width=&quot;60%&quot; /&gt;&lt;/p&gt; &lt;blockquote&gt; &lt;p&gt;The principle states:&lt;/p&gt; &lt;/blockquote&gt; &lt;ol&gt; &lt;li&gt; &lt;p&gt;High-level modules should not depend on low-level modules. Both should depend on abstractions.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Abstractions should not depend on details. Details should depend on abstractions.&lt;/p&gt; &lt;/li&gt; &lt;/ol&gt; &lt;hr /&gt; &lt;h4 id=&quot;5-isp-interface-segregation-principle&quot;&gt;5. ISP (Interface Segregation Principle)&lt;/h4&gt; &lt;p class=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/PostImages/ISP.jpg&quot; alt=&quot;dot&quot; height=&quot;50%&quot; width=&quot;50%&quot; /&gt;&lt;/p&gt; &lt;blockquote&gt; &lt;p&gt;The interface-segregation principle (ISP) states that: “No client should be forced to depend on methods it does not use. “&lt;/p&gt; &lt;/blockquote&gt; &lt;blockquote&gt; &lt;p&gt;ISP splits interfaces that are very large into smaller and more specific ones so that clients will only have to know about the methods that are of interest to them. Such shrunken interfaces are also called role interfaces. ISP is intended to keep a system decoupled and thus easier to refactor, change, and redeploy. ISP is one of the five SOLID principles of object-oriented design, similar to the High Cohesion Principle of GRASP.&lt;/p&gt; &lt;/blockquote&gt; &lt;hr /&gt; &lt;h4 id=&quot;6-lkp-least-knowledge-principle&quot;&gt;6. LKP (Least Knowledge Principle)&lt;/h4&gt; &lt;p class=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/PostImages/LKP.jpg&quot; alt=&quot;dot&quot; height=&quot;50%&quot; width=&quot;50%&quot; /&gt;&lt;/p&gt; &lt;blockquote&gt; &lt;p&gt;The principle states:&lt;/p&gt; &lt;ol&gt; &lt;li&gt;Each unit should have only limited knowledge about other units: only units “closely” related to the current unit.&lt;/li&gt; &lt;li&gt;Each unit should only talk to its friends; don’t talk to strangers.&lt;/li&gt; &lt;li&gt;Only talk to your immediate friends.&lt;/li&gt; &lt;/ol&gt; &lt;/blockquote&gt; &lt;hr /&gt; &lt;h4 id=&quot;7-composition-over-inheritance&quot;&gt;7. Composition over inheritance&lt;/h4&gt; &lt;p class=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/PostImages/COI.png&quot; alt=&quot;dot&quot; height=&quot;70%&quot; width=&quot;70%&quot; /&gt;&lt;/p&gt; &lt;blockquote&gt; &lt;p&gt;To favor composition over inheritance is a design principle that gives the design higher flexibility. It is more natural to build business-domain classes out of various components than trying to find commonality between them and creating a family tree&lt;/p&gt; &lt;/blockquote&gt; &lt;blockquote&gt; &lt;p&gt;Initial design is simplified by identifying system object behaviors in separate interfaces instead of creating a hierarchical relationship to distribute behaviors among business-domain classes via inheritance. This approach more easily accommodates future requirements changes that would otherwise require a complete restructuring of business-domain classes in the inheritance model. Additionally, it avoids problems often associated with relatively minor changes to an inheritance-based model that includes several generations of classes.&lt;/p&gt; &lt;/blockquote&gt; &lt;hr /&gt; &lt;blockquote&gt; &lt;p&gt;&lt;strong&gt;End –Cheng Gu&lt;/strong&gt;&lt;/p&gt; &lt;/blockquote&gt;</content><author><name></name></author><summary type="html">For making our code system more stable and portability, esay to maintain, follow the solid design principle is significant.</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/assets/images/post11.png"/></entry><entry><title type="html">Transparent Effects</title><link href="http://localhost:4000/2018/07/10/Alpha/" rel="alternate" type="text/html" title="Transparent Effects"/><published>2018-07-10T07:15:05-07:00</published><updated>2018-07-10T07:15:05-07:00</updated><id>http://localhost:4000/2018/07/10/Alpha</id><content type="html" xml:base="http://localhost:4000/2018/07/10/Alpha/">&lt;p&gt;In Game Development, we often use two ways to achieve transparent effect, Aplha Test and Alpha Blending.&lt;/p&gt; &lt;hr /&gt; &lt;h4 id=&quot;1-z-buffer-depth-buffer&quot;&gt;1. Z-Buffer (Depth Buffer)&lt;/h4&gt; &lt;p class=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/PostImages/z_buffer.png&quot; alt=&quot;dot&quot; height=&quot;50%&quot; width=&quot;50%&quot; /&gt;&lt;/p&gt; &lt;blockquote&gt; &lt;p&gt;Z-Buffer is used to solve the problems of visibility. It can decide which parts of the object to render first, and which parts of the objects will render later(can be blocked).&lt;/p&gt; &lt;/blockquote&gt; &lt;p&gt;The basic idea is to determine the distance between the camera and the object based on the value of the z-buffer. For example, when we want to render an fragment, the fragment’s depth value will be compared to the depth in the z-buffer (If the ZTest is On). If its depth value is smaller, it means this object is more far away from the camer. so this frament should not be rendered onto screen (which means it is covered by something); Otherwise, this fragment should replace the depth value which is in the z-buffer.&lt;/p&gt; &lt;hr /&gt; &lt;h4 id=&quot;2-alpha-test-vs-alpha-blending&quot;&gt;2. Alpha Test vs Alpha Blending&lt;/h4&gt; &lt;p class=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/PostImages/alpha.gif&quot; alt=&quot;dot&quot; height=&quot;70%&quot; width=&quot;70%&quot; /&gt;&lt;/p&gt; &lt;p&gt;&lt;strong&gt;&lt;em&gt;Alpha Test:&lt;/em&gt;&lt;/strong&gt;: As long as there is one fragment’s alpha value does not meet the conditions, the fragment which corresponding to it will be discarded (into a completely transparent fragment). Otherwise, it will be rendered as an opaque object.&lt;/p&gt; &lt;p&gt;&lt;strong&gt;&lt;em&gt;Alpha Blending&lt;/em&gt;&lt;/strong&gt;: Through the Alpha blending, we can get a translucent effect. it will combine the current fragment’s alpha value with the color value which has already been stored in the color buffer, to form a new color, but Alpha Blending needs to Turn Off the ZWrite. Therefore, we need to be careful with the rendering order when we are doing alpha blending.&lt;/p&gt; &lt;hr /&gt; &lt;h4 id=&quot;3-create-a-alpha-test-shader-in-unity&quot;&gt;3. Create A Alpha Test Shader In Unity&lt;/h4&gt; &lt;p class=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/PostImages/alpha_test.png&quot; alt=&quot;dot&quot; height=&quot;70%&quot; width=&quot;70%&quot; /&gt;&lt;/p&gt; &lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cg&quot; data-lang=&quot;cg&quot;&gt; Shader &quot;MyShader/AlphaTest&quot; { Properties { _Color(&quot;Color&quot;, Color) = (1,1,1,1) _MainTex(&quot;Main Texture&quot;, 2D)= &quot;white&quot;{} _Cutoff(&quot;Alpha Cutoff&quot;, Range(0,1)) = 0.5 } SubShader { // Usually when utilize the alpha test we should have these three tags Tags { &quot;Queue&quot; = &quot;AlphaTest&quot; &quot;IgnoreProjector&quot; = &quot;True&quot; &quot;RenderType&quot; = &quot;TransparentCutout&quot; } Pass { Tags{ &quot;LightMode&quot; = &quot;ForwardBase&quot; } CGPROGRAM #pragma vertex vert #pragma fragment frag #include &quot;Lighting.cginc&quot; fixed4 _Color; sampler2D _MainTex; float4 _MainTex_ST; fixed _Cutoff; struct a2v { float4 vertex : POSITION; float3 normal : NORMAL; float4 texcoord : TEXCOORD0; }; struct v2f { float4 pos : SV_POSITION; float3 worldNormal : TEXCOORD0; float3 worldVertex : TEXCOORD1; float2 uv : TEXCOORD2; }; v2f vert(a2v v) { v2f f; f.pos = mul(UNITY_MATRIX_MVP, v.vertex); f.worldNormal = mul(_Object2World, v.normal); f.worldVertex = mul(v.vertex, _World2Object); f.uv = v.texcoord.xy*_MainTex_ST.xy+_MainTex_ST.zw; return f; } fixed4 frag(v2f f): SV_Target { fixed3 worldNormal = normalize(f.worldNormal); fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(f.worldVertex)); fixed4 texColor = tex2D(_MainTex, f.uv); // Alpha Test if((texColor.a - _Cutoff) &amp;lt; 0.0){ discard; } // or use clip function //clip(texColor.a - _Cutoff); fixed3 albedo = texColor.rgb * _Color.rgb; fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo; fixed3 diffuse = _LightColor0.rgb * albedo * saturate(dot(worldNormal,worldLightDir)); fixed3 c = ambient + diffuse; return fixed4(c, 1.0); } ENDCG } } }&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt; &lt;hr /&gt; &lt;h4 id=&quot;4-create-a-alpha-blending-shader-in-unity&quot;&gt;4. Create A Alpha Blending Shader In Unity&lt;/h4&gt; &lt;p class=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/PostImages/Alpha Blending.png&quot; alt=&quot;dot&quot; height=&quot;70%&quot; width=&quot;70%&quot; /&gt;&lt;/p&gt; &lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cg&quot; data-lang=&quot;cg&quot;&gt; Shader &quot;MyShader/AlphaBlending&quot; { Properties { _Color(&quot;Main Tint&quot;, Color) =(1,1,1,1) _MainTex(&quot;Main Texture&quot;, 2D) = &quot;white&quot;{} _AlphaScale (&quot;Alpha Scale&quot;, Range(0, 1)) = 1 } SubShader { Tags{ &quot;Queue&quot; = &quot;Transparent&quot; &quot;IgnoreProjector&quot; = &quot;True&quot; &quot;RenderType&quot; = &quot;Transparent&quot; } // The first Pass only for store the model's depth info into the z-buffer, // to eliminate the fragment which covered by itself in the model Pass { ZWrite On // ColorMask use for mask Color in the model. // ColorMask RGB: Mask RGB Color // ColorMask A: Mask Alpha Channel // ColorMask 0: Mask all color, but since ZWrite is On, it will only pass the z-buffer ColorMask 0 } Pass { Tags{ &quot;LightMode&quot; = &quot;ForwardBase&quot; } ZWrite Off // not passing z-buffer // The semantic for blending mode // Blend Off : Close Blending // Blend SrcFactor DstFactor: Open Blending, and Set Blending factor. // Color in the Color Buffer = The object's fragment color * SrcFactor + The color which is already in color buffer * DstFactor // Blend SrcFactor DstFactor, SrcFactorA DstFactorA: Same as above but using different factor for blending alpha channel Blend SrcAlpha OneMinusSrcAlpha CGPROGRAM #pragma vertex vert #pragma fragment frag #include &quot;Lighting.cginc&quot; fixed4 _Color; sampler2D _MainTex; float4 _MainTex_ST; fixed _AlphaScale; struct a2v { float4 vertex : POSITION; float3 normal : NORMAL; float4 texcoord : TEXCOORD0; }; struct v2f { float4 pos : SV_POSITION; float3 worldNormal : TEXCOORD0; float3 worldVertex : TEXCOORD1; float2 uv : TEXCOORD2; }; v2f vert(a2v v) { v2f f; f.pos = UnityObjectToClipPos(v.vertex); f.worldNormal = mul(unity_ObjectToWorld, v.normal); f.worldVertex = mul(v.vertex, unity_WorldToObject); f.uv = v.texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw; return f; } fixed4 frag(v2f f): SV_Target { fixed3 worldNormal = normalize(f.worldNormal); fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(f.worldVertex)); fixed4 texColor = tex2D(_MainTex,f.uv); fixed3 albedo = texColor.rgb * _Color.rgb; fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo; fixed3 diffuse = _LightColor0.rgb * albedo *saturate(dot(worldNormal,worldLightDir)); fixed3 c = diffuse + ambient; return fixed4(c,texColor.a * _AlphaScale); } ENDCG } } }&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt; &lt;hr /&gt; &lt;h4 id=&quot;5-shaderlab-blending-command&quot;&gt;5. ShaderLab Blending Command&lt;/h4&gt; &lt;hr /&gt; &lt;table&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;Command&lt;/td&gt; &lt;td&gt;Description&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Blend SrcFactor DstFactor&lt;/td&gt; &lt;td&gt;Open Blending, and Set Blending factor.Color in the Color Buffer = The object’s fragment color * SrcFactor + The color which is already in color buffer * DstFactor&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Blend SrcFactor DstFactor, SrcFactorA DstFactorA&lt;/td&gt; &lt;td&gt;Same function as above, butbut using different factor for blending alpha channe&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;hr /&gt; &lt;blockquote style=&quot;color: red&quot;&gt; &lt;p&gt;So, What are these factors?&lt;/p&gt; &lt;/blockquote&gt; &lt;hr /&gt; &lt;table&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;Parameters&lt;/td&gt; &lt;td&gt;Description&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;One&lt;/td&gt; &lt;td&gt;Factor is 1&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Zero&lt;/td&gt; &lt;td&gt;Factor is 0&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;SrcColor&lt;/td&gt; &lt;td&gt;Factor is the source color value&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;SrcAlpha&lt;/td&gt; &lt;td&gt;Factor is the source alpha value&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;DstColor&lt;/td&gt; &lt;td&gt;Factor is the target color value&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;DstAlpha&lt;/td&gt; &lt;td&gt;Factor is the target alpha value&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;OneMinusSrcColor&lt;/td&gt; &lt;td&gt;Factor is 1 - source color value&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;OneMinusSrcAlpha&lt;/td&gt; &lt;td&gt;Factor is 1 - source alpha value&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;OneMinusDstColor&lt;/td&gt; &lt;td&gt;Factor is 1 - target color value&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;OneMinusDstAlpha&lt;/td&gt; &lt;td&gt;Factor is 1 - target alpha value&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;hr /&gt; &lt;blockquote style=&quot;color: red&quot;&gt; &lt;p&gt;We also can sue ShaderLab’s BlendOp Command to perform various blending operations&lt;/p&gt; &lt;/blockquote&gt; &lt;hr /&gt; &lt;table&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;Operation&lt;/td&gt; &lt;td&gt;Description&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Add&lt;/td&gt; &lt;td&gt;O = SrcFactor * SourceColor + DstFactor * TargetColor&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Sub&lt;/td&gt; &lt;td&gt;O = SrcFactor * SourceColor - DstFactor * TargetColor&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;RevSub&lt;/td&gt; &lt;td&gt;O = DstFactor * TargetColor - SrcFactor * SourceColor&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Min&lt;/td&gt; &lt;td&gt;O = (min(S.r, D.r), min(S.g, D.g), min(S.b, D.b), min(S.a, D.a))&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Max&lt;/td&gt; &lt;td&gt;O = (max(S.r, D.r), max(S.g, D.g), max(S.b, D.b), max(S.a, D.a))&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;hr /&gt; &lt;blockquote style=&quot;color: red&quot;&gt; &lt;p&gt;The Common Blending Type:&lt;/p&gt; &lt;/blockquote&gt; &lt;p class=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/PostImages/Blending Mode.png&quot; alt=&quot;dot&quot; height=&quot;70%&quot; width=&quot;70%&quot; /&gt;&lt;/p&gt; &lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cg&quot; data-lang=&quot;cg&quot;&gt;Blend SrcAlpha OneMinusSrcAlpha // Normal Blend OneMinusDstColor One // Soft Additive Blend DstColor Zero // Multiply Blend DstColor SrcColor // 2x Multiply BlendOp Min // Darken Blend One One BlendOp Max // Lighten Blend One One Blend OneMinusDstColor One // Screen Blend One OneMinusSrcColor // Same as above Blend One One // Linear Dodge&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt; &lt;hr /&gt; &lt;blockquote&gt; &lt;p&gt;&lt;strong&gt;End –Cheng Gu&lt;/strong&gt;&lt;/p&gt; &lt;/blockquote&gt;</content><author><name></name></author><summary type="html">In Game Development, we often use two ways to achieve transparent effect, Aplha Test and Alpha Blending.</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/assets/images/post10.png"/></entry><entry><title type="html">Ramp &amp;amp; Mask Texture</title><link href="http://localhost:4000/2018/06/29/Ramp-And-Mask/" rel="alternate" type="text/html" title="Ramp &amp; Mask Texture"/><published>2018-06-29T07:15:05-07:00</published><updated>2018-06-29T07:15:05-07:00</updated><id>http://localhost:4000/2018/06/29/Ramp-And-Mask</id><content type="html" xml:base="http://localhost:4000/2018/06/29/Ramp-And-Mask/">&lt;p&gt;Ramp Texture allows us to control the diffuse light of an object. Mask Texture can protect some part of the texture not be influence.&lt;/p&gt; &lt;hr /&gt; &lt;h4 id=&quot;1-ramp-texture&quot;&gt;1. Ramp Texture&lt;/h4&gt; &lt;p class=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/PostImages/ramp.png&quot; alt=&quot;dot&quot; height=&quot;70%&quot; width=&quot;70%&quot; /&gt;&lt;/p&gt; &lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cg&quot; data-lang=&quot;cg&quot;&gt; Shader &quot;MyShader/RampMap&quot; { Properties { _Color (&quot;Color Tint&quot;, Color) = (1, 1, 1, 1) _RampTex (&quot;Ramp Tex&quot;, 2D) = &quot;white&quot; {} _Specular (&quot;Specular&quot;, Color) = (1, 1, 1, 1) _Gloss (&quot;Gloss&quot;, Range(8.0, 256)) = 20 } SubShader { Pass { Tags { &quot;LightMode&quot;=&quot;ForwardBase&quot; } CGPROGRAM #pragma vertex vert #pragma fragment frag #include &quot;Lighting.cginc&quot; fixed4 _Color; sampler2D _RampTex; float4 _RampTex_ST; fixed4 _Specular; float _Gloss; struct a2v { float4 vertex : POSITION; float3 normal : NORMAL; float4 texcoord : TEXCOORD0; }; struct v2f { float4 pos : SV_POSITION; float3 worldNormal : TEXCOORD0; float3 worldPos : TEXCOORD1; float2 uv : TEXCOORD2; }; v2f vert(a2v v) { v2f o; o.pos = UnityObjectToClipPos(v.vertex); o.worldNormal = UnityObjectToWorldNormal(v.normal); o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz; o.uv = TRANSFORM_TEX(v.texcoord, _RampTex); return o; } fixed4 frag(v2f i) : SV_Target { fixed3 worldNormal = normalize(i.worldNormal); fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos)); fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz; // Use the texture to sample the diffuse color fixed halfLambert = 0.5 * dot(worldNormal, worldLightDir) + 0.5; fixed3 diffuseColor = tex2D(_RampTex, fixed2(halfLambert, halfLambert)).rgb * _Color.rgb; fixed3 diffuse = _LightColor0.rgb * diffuseColor; fixed3 viewDir = normalize(UnityWorldSpaceViewDir(i.worldPos)); fixed3 halfDir = normalize(worldLightDir + viewDir); fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(max(0, dot(worldNormal, halfDir)), _Gloss); return fixed4(ambient + diffuse + specular, 1.0); } ENDCG } } }&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt; &lt;hr /&gt; &lt;h4 id=&quot;2-mask-texture&quot;&gt;2. Mask Texture&lt;/h4&gt; &lt;p class=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/PostImages/mask.png&quot; alt=&quot;dot&quot; height=&quot;70%&quot; width=&quot;70%&quot; /&gt;&lt;/p&gt; &lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cg&quot; data-lang=&quot;cg&quot;&gt; Shader &quot;MyShader/7. MaskMap&quot; { Properties { _Color(&quot;Color&quot;, Color) = (1,1,1,1) _MainTex(&quot;MainTex&quot;,2D) = &quot;white&quot;{} _BumpMap(&quot;Normal Map&quot;,2D) = &quot;bump&quot;{} _BumpScale(&quot;Bump Scale&quot;, Float) = 1.0 _SpecularMask (&quot;Specular Mask&quot;, 2D) = &quot;white&quot;{} _SpecularScale(&quot;Specular Scale&quot;, Float) = 1 _Specular(&quot;Specular&quot;, Color) =(1,1,1,1) _Gloss(&quot;Gloss&quot;,Range(5,100)) = 5 } SubShader { Pass { Tags{&quot;LightMode&quot; = &quot;ForwardBase&quot;} CGPROGRAM #pragma vertex vert #pragma fragment frag #include &quot;Lighting.cginc&quot; fixed4 _Color; sampler2D _MainTex; float4 _MainTex_ST; sampler2D _BumpMap; float _BumpScale; sampler2D _SpecularMask; float _SpecularScale; fixed4 _Specular; float _Gloss; struct a2v { float4 vertex : POSITION; float3 normal : NORMAL; float4 tangent : TANGENT; float4 texcoord : TEXCOORD0; }; struct v2f { float4 pos : SV_POSITION; float2 uv : TEXCOORD0; float3 lightDir : TEXCOORD1; float3 viewDir : TEXCOORD2; }; v2f vert(a2v v) { v2f f; f.pos = UnityObjectToClipPos(v.vertex); f.uv = v.texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw; TANGENT_SPACE_ROTATION; f.lightDir = mul(rotation, ObjSpaceLightDir(v.vertex)).xyz; f.viewDir = mul(rotation, ObjSpaceViewDir(v.vertex)).xyz; return f; } fixed4 frag(v2f f) : SV_Target { fixed3 tangentLightDir = normalize(f.lightDir); fixed3 tangentViewDir = normalize(f.viewDir); fixed3 tangentNormalDir = UnpackNormal(tex2D(_BumpMap,f.uv)); tangentNormalDir.xy *= _BumpScale; tangentNormalDir.z = sqrt(1 - saturate(dot(tangentNormalDir.xy, tangentNormalDir.xy))); fixed3 albedo = tex2D(_MainTex, f.uv).rgb * _Color.rgb; fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.rgb * albedo; fixed3 diffuse = _LightColor0.rgb * albedo * saturate(dot(tangentLightDir,tangentNormalDir)); fixed3 halfDir = normalize(tangentViewDir + tangentLightDir); fixed specularMask = tex2D(_SpecularMask, f.uv).r *_SpecularScale; fixed3 specular = _LightColor0.rgb * _Specular.rgb * specularMask * pow(saturate(dot(halfDir,tangentNormalDir)),_Gloss); fixed3 c = ambient + diffuse + specular; return fixed4 (c,1); } ENDCG } } }&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt; &lt;hr /&gt; &lt;blockquote&gt; &lt;p&gt;&lt;strong&gt;End –Cheng Gu&lt;/strong&gt;&lt;/p&gt; &lt;/blockquote&gt;</content><author><name></name></author><summary type="html">Ramp Texture allows us to control the diffuse light of an object. Mask Texture can protect some part of the texture not be influence.</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/assets/images/post9.png"/></entry><entry><title type="html">Bump Mapping</title><link href="http://localhost:4000/2018/06/23/Bump-Mapping/" rel="alternate" type="text/html" title="Bump Mapping"/><published>2018-06-23T07:15:05-07:00</published><updated>2018-06-23T07:15:05-07:00</updated><id>http://localhost:4000/2018/06/23/Bump-Mapping</id><content type="html" xml:base="http://localhost:4000/2018/06/23/Bump-Mapping/">&lt;p&gt;Bump mapping is used for giving models more details with cheap costs by modifying the normal of the model .&lt;/p&gt; &lt;p&gt;This method doesn’t change the models detail level, but give us a visual effect that the model has more details after bump mapping.&lt;/p&gt; &lt;hr /&gt; &lt;h4 id=&quot;1-two-kinds-of--bump-maping&quot;&gt;1. Two Kinds of Bump Maping&lt;/h4&gt; &lt;p&gt;There are two common ways to do the bump mapping, which are Height Mapping, and Normal Mapping.&lt;/p&gt; &lt;p class=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/PostImages/hm_nm.png&quot; alt=&quot;dot&quot; height=&quot;70%&quot; width=&quot;70%&quot; /&gt;&lt;/p&gt; &lt;p&gt;Use a height map to simulate the surface displacement. If the color are darker, the surface are lower; if the color are lighter, the surface are higher. The advantage of this using height map is make the height of the surface more obviouse to see. But it is also more expensive performance.&lt;/p&gt; &lt;p&gt;Normally we will use normal map to modify the light. In Normal map, it represents the direction of the normal. The range of normal’s component range is [-1,1], but the pixel’s component range is [0,1].So that we need to do a mapping&lt;/p&gt; &lt;blockquote&gt; &lt;p&gt;Pixel = (Normal + 1) / 2&lt;/p&gt; &lt;/blockquote&gt; &lt;p&gt;This will require us to use a inverse function to get the original normal direction after mapping the pixel in the Shader&lt;/p&gt; &lt;blockquote&gt; &lt;p&gt;Normal = Pixel x 2 - 1&lt;/p&gt; &lt;/blockquote&gt; &lt;p class=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/PostImages/tangent space and model space.png&quot; alt=&quot;dot&quot; height=&quot;70%&quot; width=&quot;70%&quot; /&gt;&lt;/p&gt; &lt;blockquote&gt; &lt;p&gt;The above image respectively gives us the normal map in the model space and tangent space.&lt;/p&gt; &lt;/blockquote&gt; &lt;hr /&gt; &lt;h4 id=&quot;2-normal-mapping-in-tangent-space&quot;&gt;2. Normal Mapping in Tangent Space&lt;/h4&gt; &lt;blockquote&gt; &lt;p&gt;The advantage in the tangent space to calculate normal mapping is more efficient don’t need too many conversion.&lt;/p&gt; &lt;/blockquote&gt; &lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cg&quot; data-lang=&quot;cg&quot;&gt; Shader &quot;MyShader/NormalMapInTangentSpace&quot; { Properties { _Color(&quot;Color&quot;,Color) = (1,1,1,1) _MainTex (&quot;Texture&quot;, 2D) = &quot;white&quot; {} _BumpMap(&quot;Normal Map&quot;,2D) = &quot;bump&quot; {} _BumpScale(&quot;Bump Scale&quot;,Float) = 1.0 _Specular(&quot;Specular&quot;,Color) = (1,1,1,1) _Gloss(&quot;Gloss&quot;,Range(5,100)) = 5 } SubShader { Pass { Tags{&quot;LightMode&quot; = &quot;ForwardBase&quot;} CGPROGRAM #pragma vertex vert #pragma fragment frag #include &quot;Lighting.cginc&quot; fixed4 _Color; sampler2D _MainTex; float4 _MainTex_ST; sampler2D _BumpMap; float4 _BumpMap_ST; float _BumpScale; fixed4 _Specular; float _Gloss; struct a2v { float4 vertex : POSITION; float3 normal : NORMAL; // We use TANGENT semantic to describe a float4 type variable tangent, // to tell CG give the vertices' tangent direction to the variable tangent. // compared with normal, tangent is a float4 variable, // because we need tangent.w to determine the binormal's direction float4 tangent : TANGENT; float4 texcoord : TEXCOORD0; }; struct v2f { float4 pos : SV_POSITION; float4 uv : TEXCOORD0; float3 lightDir : TEXCOORD1; float3 viewDir : TEXCOORD2; }; v2f vert(a2v v) { v2f o; o.pos = UnityObjectToClipPos(v.vertex); o.uv.xy = v.texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw; o.uv.zw = v.texcoord.xy * _BumpMap_ST.xy + _BumpMap_ST.zw; // Compute the binormal // float3 binormal = cross( normalize(v.normal), normalize(v.tangent.xyz) ) * v.tangent.w; // // Construct a matrix which transform vectors from object space to tangent space // float3x3 rotation = float3x3(v.tangent.xyz, binormal, v.normal); // Or just use the built-in macro TANGENT_SPACE_ROTATION; // // // Transform the light direction from object space to tangent space o.lightDir = mul(rotation, normalize(ObjSpaceLightDir(v.vertex))).xyz; // // Transform the view direction from object space to tangent space o.viewDir = mul(rotation, normalize(ObjSpaceViewDir(v.vertex))).xyz; return o; } fixed4 frag(v2f f) : SV_Target { fixed3 tangentLightDir = normalize(f.lightDir); fixed3 tangentViewDir = normalize(f.viewDir); fixed4 packedNormal = tex2D(_BumpMap,f.uv.zw); // if the texture is not marked as &quot;Normal Map&quot; //fixed3 tangentNormal; //tangentNormal.xy =(packedNormal.xy * 2 - 1) * _BumpScale; //else fixed3 tangentNormal = UnpackNormal(packedNormal); tangentNormal.xy *= _BumpScale; tangentNormal.z = sqrt(1.0 - saturate(dot(tangentNormal.xy, tangentNormal.xy))); fixed3 albedo = tex2D(_MainTex, f.uv.xy).rgb * _Color.rgb; fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo; fixed3 diffuse = _LightColor0.rgb * albedo * saturate(dot(tangentNormal,tangentLightDir)); fixed3 halfDir = normalize(tangentLightDir + tangentViewDir); fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(saturate(dot(halfDir, tangentNormal)),_Gloss); fixed3 c = ambient + diffuse + specular; return fixed4(c,1); } ENDCG } } FallBack &quot;Specular&quot; }&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt; &lt;hr /&gt; &lt;h4 id=&quot;3-normal-mapping-in-world-space&quot;&gt;3. Normal Mapping in World Space&lt;/h4&gt; &lt;blockquote&gt; &lt;p&gt;However, from a general point of view, normal mapping in world space is better than in tangent space. For example if we need to use Cubemap to mapping the environment we have to&lt;/p&gt; &lt;/blockquote&gt; &lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cg&quot; data-lang=&quot;cg&quot;&gt; Shader &quot;MyShader/NormalMapInWorldSpace&quot; { Properties { _Color (&quot;Color Tint&quot;, Color) = (1, 1, 1, 1) _MainTex (&quot;Main Tex&quot;, 2D) = &quot;white&quot; {} _BumpMap (&quot;Normal Map&quot;, 2D) = &quot;bump&quot; {} _BumpScale (&quot;Bump Scale&quot;, Float) = 1.0 _Specular (&quot;Specular&quot;, Color) = (1, 1, 1, 1) _Gloss (&quot;Gloss&quot;, Range(8.0, 256)) = 20 } SubShader { Pass { Tags { &quot;LightMode&quot;=&quot;ForwardBase&quot; } CGPROGRAM #pragma vertex vert #pragma fragment frag #include &quot;Lighting.cginc&quot; fixed4 _Color; sampler2D _MainTex; float4 _MainTex_ST; sampler2D _BumpMap; float4 _BumpMap_ST; float _BumpScale; fixed4 _Specular; float _Gloss; struct a2v { float4 vertex : POSITION; float3 normal : NORMAL; float4 tangent : TANGENT; float4 texcoord : TEXCOORD0; }; struct v2f { float4 pos : SV_POSITION; float4 uv : TEXCOORD0; float4 TtoW0 : TEXCOORD1; float4 TtoW1 : TEXCOORD2; float4 TtoW2 : TEXCOORD3; }; v2f vert(a2v v) { v2f o; o.pos = mul(UNITY_MATRIX_MVP, v.vertex); o.uv.xy = v.texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw; o.uv.zw = v.texcoord.xy * _BumpMap_ST.xy + _BumpMap_ST.zw; float3 worldPos = mul(_Object2World, v.vertex).xyz; fixed3 worldNormal = UnityObjectToWorldNormal(v.normal); fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz); fixed3 worldBinormal = cross(worldNormal, worldTangent) * v.tangent.w; // Compute the matrix that transform directions from tangent space to world space // Put the world position in w component for optimization o.TtoW0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x); o.TtoW1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y); o.TtoW2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z); return o; } fixed4 frag(v2f i) : SV_Target { // Get the position in world space float3 worldPos = float3(i.TtoW0.w, i.TtoW1.w, i.TtoW2.w); // Compute the light and view dir in world space fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos)); fixed3 viewDir = normalize(UnityWorldSpaceViewDir(worldPos)); // Get the normal in tangent space fixed3 bump = UnpackNormal(tex2D(_BumpMap, i.uv.zw)); bump.xy *= _BumpScale; bump.z = sqrt(1.0 - saturate(dot(bump.xy, bump.xy))); // Transform the narmal from tangent space to world space bump = normalize(half3(dot(i.TtoW0.xyz, bump), dot(i.TtoW1.xyz, bump), dot(i.TtoW2.xyz, bump))); fixed3 albedo = tex2D(_MainTex, i.uv).rgb * _Color.rgb; fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo; fixed3 diffuse = _LightColor0.rgb * albedo * max(0, dot(bump, lightDir)); fixed3 halfDir = normalize(lightDir + viewDir); fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(max(0, dot(bump, halfDir)), _Gloss); return fixed4(ambient + diffuse + specular, 1.0); } ENDCG } } FallBack &quot;Specular&quot; }&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt; &lt;hr /&gt; &lt;blockquote&gt; &lt;p&gt;&lt;strong&gt;End –Cheng Gu&lt;/strong&gt;&lt;/p&gt; &lt;/blockquote&gt;</content><author><name></name></author><summary type="html">Bump mapping is used for giving models more details with cheap costs by modifying the normal of the model .</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/assets/images/post8.jpg"/></entry></feed>