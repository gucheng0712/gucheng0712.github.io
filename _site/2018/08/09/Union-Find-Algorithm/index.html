<!DOCTYPE html> <html> <head> <meta http-equiv="Content-Type" content="text/html; charset=utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1"> <link rel="stylesheet" type="text/css" href="/assets/css/materialize.css"> <link rel="stylesheet" type="text/css" href="/assets/main.css"> <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet"> <link rel="stylesheet" href="https://cdn.rawgit.com/konpa/devicon/df6431e323547add1b4cf45992913f15286456d3/devicon.min.css"> <title>Suzuka Site</title> </head> <body> <div class="container"> <div class="col s10"> <div class="row" style="padding:10px;"> <a id="home" class="waves-effect waves-light btn white-text darken-2 grey z-depth-4" href="/#blog"><i class="material-icons">arrow_back</i></a> </div> <h3 class="post-title" itemprop="name headline" style="text-align:center">Union Find Algorithm</h3> <p class="post-meta"> <time datetime="2018-08-09T07:15:05-07:00" itemprop="datePublished"> Aug 9, 2018 </time> </p> <div class="post-content" itemprop="articleBody"> <p>This article focuses on an algorithm for solving problems such as dynamic connectivity, using a data structure called Union Find.</p> <p>The Evolutionary history of Union Find is From Quick Find –&gt; Union Find –&gt; Weighted Union Find</p> <blockquote style="color: red"> <p>This is the Performance consumption table:</p> </blockquote> <p class="center"><img src="/assets/images/PostImages/Performance consumption table.png" alt="dot" height="50%" width="50%"/></p> <hr/> <h4 id="dynamic-connectivity-client">Dynamic-Connectivity Client</h4> <blockquote> <p>Code:</p> </blockquote> <figure class="highlight"><pre><code class="language-cg" data-lang="cg"> 
public static void main(String[] args)
{
    int N = StdIn.readInt();
    UF uf = new UF(N);
    while (!StdIn.isEmpty())
    {
        int p = StdIn.readInt();    
        int q = StdIn.readInt();
        if (!uf.connected(p, q))
        {
            uf.union(p, q);
            StdOut.println(p + " " + q);
        }
    }
}</code></pre></figure> <hr/> <h4 id="quick-find">Quick Find</h4> <p class="center"><img src="/assets/images/PostImages/qf.png" alt="dot" height="70%" width="70%"/></p> <blockquote> <p>Code:</p> </blockquote> <figure class="highlight"><pre><code class="language-cg" data-lang="cg"> 
public class QuickFindUF
{
    private int[] id;
    private int count;
    public QuickFindUF(int N)
    {
        id = new int[N];
        count =N;
        // Set ID of earch object to itself
        for (int i = 0; i &lt; N; i++)
            id[i] = i;
    }
    
    // check if p and q are in the same component
    public boolean connected(int p, int q)
    { 
        return id[p] == id[q]; 
    }
    
    // find the id for the given index
    public int find(int p)
    {
        return id[p]; 
    }
    
    public int count()
    {
        return count;
    }

    // change all id[p] to id[q]
    public void union(int p, int q)
    {
        int pid = id[p];
        int qid = id[q];
       
        for (int i = 0; i &lt; id.length; i++)
            if (id[i] == pid) id[i] = qid;
        count--;
    }
}</code></pre></figure> <hr/> <h4 id="quick-union">Quick Union</h4> <p class="center"><img src="/assets/images/PostImages/uf.png" alt="dot" height="70%" width="70%"/></p> <blockquote> <p>Code:</p> </blockquote> <figure class="highlight"><pre><code class="language-cg" data-lang="cg"> 
public class QuickUnionUF
{
    private int[] id;
    private int count;
    public QuickUnionUF(int N)
    {
        id = new int[N];
        count =N;
        // Set ID of earch object to itself
        for (int i = 0; i &lt; N; i++)
            id[i] = i;
    }
    
    // check if p and q have same root
    public boolean connected(int p, int q)
    { 
        return root(p) == root(q); 
    }
    
    // find the id for the given index
    public int find(int i)
    {
        return id[i]; 
    }
    
    public int root(int i)
    {
        //chase parent pointers until reach root
        while(i!=id[i])
        {
            // Make every other node in path point to its grandparent
            id[i] = id[id[i]]; // Pass Compression
            
            i = id[i];
        }
        return i;
    }
    
    public int count()
    {
        return count;
    }
    
    // change all id[p] to id[q]
    public void union(int p, int q)
    {
        int pRoot = root(p);
        int qRoot = root(q);
        
        if(pRoot == qRoot) return;
        id[pRoot] = qRoot; // change root of p to point to root of q
        count--;
    }
}</code></pre></figure> <hr/> <h4 id="weighted-quick-union">Weighted Quick Union</h4> <p class="center"><img src="/assets/images/PostImages/wuf.png" alt="dot" height="70%" width="70%"/></p> <blockquote> <p>Code:</p> </blockquote> <figure class="highlight"><pre><code class="language-cg" data-lang="cg"> 
public class WeightedQuickUnionUF
{
    private int[] id;
    private int[] size; // to count number of objs in the each root
    private int count;
    public WeightedQuickUnionUF(int N)
    {
        id = new int[N];
        size = new int[N];
        count = N;
        // Set ID of earch object to itself
        for (int i = 0; i &lt; N; i++)
            id[i] = i;
    }
    
    // check if p and q have same root
    public boolean connected(int p, int q)
    { 
        return root(p) == root(q); 
    }
    
    // find the id for the given index
    public int find(int i)
    {
        return id[i]; 
    }
    
    public int root(int i)
    {
        //chase parent pointers until reach root
        while(i!=id[i])
        {
            // Make every other node in path point to its grandparent
            id[i] = id[id[i]]; // Pass Compression
                        
            i = id[i];
        }
        return i;
    }
    
    public int count()
    {
        return count;
    }
    
    // change all id[p] to id[q]
    public void union(int p, int q)
    {
        int pRoot = root(p);
        int qRoot = root(q);
        
        if(pRoot == qRoot) return;
        
        // Link root of smaller tree to root of larger tree
        if(size[pRoot] &lt; size[qRoot])
        {
            id[qRoot] = pRoot;// change root of q to point to root of p
            size[pRoot] += size[qRoot]; // update the tree size
        }
        else
        {
            id[pRoot] = qRoot;// change root of p to point to root of q
            size[qRoot] += size[pRoot]; // update the tree size
        }
        count--;
    }
}</code></pre></figure> <hr/> <h4 id="comparsion-between-if-it-is-weighted-or-not">Comparsion between if it is Weighted or not</h4> <p class="center"><img src="/assets/images/PostImages/uf vs wuf.png" alt="dot" height="80%" width="80%"/></p> <hr/> <blockquote> <p><strong>End –Cheng Gu</strong></p> </blockquote> </div> </div> </div> <script type="text/javascript" src="/assets/js/jquery-3.2.1.min.js"></script> <script type="text/javascript" src="/assets/js/materialize.min.js"></script> <script src="/assets/js/init.js"></script> </body> <footer class="page-footer"> <div class="footer-copyright" style="padding-left: 30px"> <i class="material-icons" style="padding-right:5px">copyright</i> <p>2018 Copyright Cheng Gu</p> </div> </footer> </html>